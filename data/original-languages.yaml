# encoding: UTF-8
ALPACA:
  type: Programming Language
  genre: Metalanguage
  acronym-for: A Language for Programming Arbitrary Cellular Automata
  abstract: |-
    ALPACA is a meta-language for describing cellular automata. 
  commentary: |-
    The acronym is not quite accurate, as the automata are not in fact arbitrary, but it's
    a nice acronym.
    
    ALPACA is one of the few of my languages in which I've actually implemented
    other languages (or, well, cellular automata -- close enough).  These are, namely,
    [[REDGREEN]], [[Braktif]], [[Circute]], and [[Jaccia and Jacciata]].
  inception-date: 1998
  etymology:
  - acronym
  notable: true
  sample: |
    /* John Conway's Game of Life, expressed in ALPACA. */
    state Dead  " " to Alive when 3 Alive and 5 Dead;
    state Alive "*" to Dead when 4 Alive or 7 Dead.
  reference-distribution: ALPACA distribution
  implementions:
  - alpaca.pl

alpaca.pl:
  type: Language Implementation
  reference: true
  in-distribution: ALPACA distribution
  license: BSD
  implementation-type: compiler
  source-language: ALPACA
  host-language: Perl
  target-language: Perl


Befunge-93:
  type: Programming Language
  genre: Esolang
  abstract: |-
    One of the more popular languages I ever designed and implemented.
    Eventually begat [[Befunge-97]], [[Funge-98]], and [[Wierd]], and doubtless influenced
    many others.  Cited in the New Hacker's Dictionary.
  # also: known not Turing-complete
  computational-class: can simulate some push-down automata
  etymology:
  - typo
  influences:
  - Maentwrog
  sample: |2
     v    <
    >?"/",^
     >"\",^
  notable: true
  significant: true
  quotation: Hey, my archive must be corrupt.  These sources all look like garbage.
  quotation-attribution: Mark Topham
  inception-date: Sep 1993
  reference-distribution: Befunge-93 distribution
  implementations:
  - bef
  other-implementations: true

bef:
  type: Language Implementation
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: ANSI C


Befunge-97:
  type: Programming Language
  genre: Esolang
  abstract: |-
    An unimplemented attempt to improve upon Befunge-93, described
    (fairly accurately) as "brain-damaged."  This was primarily due to the
    fact that separate processes were specified\nas sharing a single stack.
    Quickly gave way to [[Funge-98]].
  inception-date: Dec 25, 1997
  etymology:
  - typo
  failure: true
  influences:
  - Befunge-93
  has-reference-distribution: false


beta-Juliet:
  type: Programming Language
  genre: Esolang
  esowiki: beta-Juliet
  summary: A minimal event-oriented programming language
  abstract: |-
    beta-Juliet is a minimal event-based language.  Each event is caused by some other event.
    Event causation is conditional based on which of two given events occurred more recently.
    
    Portia is a preprocessor for beta-Juliet which allows large, regular, finite sets of events
    to be described succinctly.
    
    Version 2.0 of beta-Juliet (formerly known as "2iota") allows infinite sets of events to be
    specified, allowing the language to be Turing-complete.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 2002
  computational-class: believed Turing-complete
  paradigms:
  - Event-oriented
  etymology:
  - automotive pun
  - feminine given name
  reference-distribution: beta-Juliet distribution
  implementations:
  - b_juliet.pl
  - 2iota

b_juliet.pl:
  type: Language Implementation
  in-distribution: beta-Juliet distribution
  license: BSD
  implementation-type: interpreter
  host-language: Perl

2iota:
  type: Language Implementation
  reference: true
  in-distribution: beta-Juliet distribution
  license: BSD
  implementation-type: interpreter
  host-language: C99


Braktif:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: |-
    Braktif is a cellular automaton modelled closely after the [[brainfuck]]
    programming language.
  computational-class: believed Turing-complete
  etymology:
  - television character
  - portmanteau
  - french
  influences:
  - brainfuck
  sample: |2
                                *
                           <<*[--]*
    000000000000000000  *[-----  --]
    -----------------d-i--         --------
  inception-date: 2005
  reference-distribution: Braktif distribution
  implementations:
  - braktif.alp

braktif.alp:
  type: Language Implementation
  reference: true
  in-distribution: Braktif distribution
  license: BSD
  implementation-type: formal description
  host-language: ALPACA


Circute:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: |-
    Circute is a cellular automaton that simulates conduits that
    carry digital signals and NAND gates that manipulate those signals.
  etymology:
  - portmanteau
  influences:
  - Wireworld
  computational-class: known not Turing-complete
  sample: |2
                      =
                      =
       #######==   ===N===   =========
       #       =   =     =   =       =
     ==N==     = ==N== ==N== =     ==N==
     =   =     = =   = =   = =     =   =
     =====     = ===== ===== =     =====
       =       =   =     =   =       =
       =============     =============
  inception-date: 2005
  reference-distribution: Circute distribution
  implementations:
  - circute.alp

circute.alp:
  type: Language Implementation
  reference: true
  in-distribution: Circute distribution
  license: BSD
  implementation-type: formal description
  host-language: ALPACA


Dieter:
  type: Programming Language
  genre: Experimental language
  summary: A language which conflates modules and type qualifiers
  abstract: |-
    Dieter (as in the German masculine given name Dieter, not dieter as in
    "one who diets") is a little experimental programming language that
    conflates *type qualifiers* with *modules* to produce something
    reminiscent of object-orientation.  It demonstrates another way of
    thinking about objects, or rather, classes: not so much as
    *aggregates of data* as *associations of predicates*.
    
    Dieter was intended as a way to make Hungarian notation part of the type
    system, and thus automatically checkable.  However, it also suggests
    possible ways of dealing with the problems of aliasing — that is,
    determining if two pointers cannot possibly point to the same data, for
    safety and optimization considerations.
  paradigms:
  - Object-oriented
  etymology:
  - masculine given name
  sample: |-
    module beefy
      procedure beef_up(x: ♥t): beefy ♥t
      begin
        return (bestow beefy x)
      end
    end.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca Oct 3, 2009
  computational-class: believed Turing-complete
  reference-distribution: Dieter distribution
  implementations:
  - dieter.py

dieter.py:
  type: Language Implementation
  in-distribution: Dieter distribution
  reference: true
  license: BSD
  implementation-type: typechecker
  host-language: Python


Eightebed:
  type: Programming Language
  genre: Esolang
  esowiki: Eightebed
  summary: A safe language with explicit memory deallocation
  abstract: |-
    Eightebed is a small language with explicit `malloc` and `free`.
    Through a modicum of static analysis
    and runtime support, Eightebed is safe: it is not possible to dereference a dangling
    pointer or otherwise incorrectly-populated memory.
    
    Eightebed was designed as a counter-example to Gregor Richards' claim that such
    a language would either need a garbage collector, or not actually implement `free`.
    Eightebed has a real `free` and has no garbage collector.
  commentary: |-
    The name "Eightebed" came from a typo by [[Alise]] for the word "enlightened".
  etymology:
  - typo
  sample: |-
    type node struct {
        int value;
        ptr to node next;
    };
    var ptr to node jim;
    var ptr to node george;
    {    
        jim = malloc node;
        if valid jim {
            [@jim].value = (1 + 4);
            george = jim;
        }
        if valid george {
            print [@george].value;
        }
        free george;
        free jim;
    }
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca Sep 1, 2010
  computational-class: believed Turing-complete
  reference-distribution: Eightebed distribution
  implementations:
  - 8ebed2c.py

8ebed2c.py:
  type: Language Implementation
  in-distribution: Eightebed distribution
  reference: yes
  license: BSD
  implementation-type: compiler
  source-language: Eightebed
  host-language: Python
  target-language: ANSI C


Full Moon Fever:
  type: Programming Language
  genre: DSL
  summary: A language for describing ANSI terminal animations
  abstract: |-
    Full Moon Fever is a language for describing ASCII animations.
    It was used to deliver animated screens on Chris Pressey's BBS
    (when it was operational in the early 90's) via ANSI terminal control codes.
    This probably counts as his first proper language, even though
    it wasn't a full programming language, because it had
    the usual machinery (syntax, parser, interpreter...)
    Lives on, in a somewhat distended form, as a sub-language of
    [[ILLGOL]].
  commentary: |-
    I believe the name "Full Moon Fever" came from a mis-remembering
    of the title of the song "Full Moon Boogie" by Jan Hammer and
    that other guy.
  etymology:
  - song title
  - error
  sample: |-
    GO 1 2 CLREOL CENTRE "Enter... the Stupid Guard." 2
    GO 1 3 CLREOL
    PAUSE 70
    GO 76 19
    PRINT "0"
    PAUSE 20
    DO 20
        LF PRINT " " LF LF PRINT "0" PAUSE 5;
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1993
  computational-class: known not Turing-complete
  has-reference-distribution: false
  implemented: true


Funge-98:
  type: Programming Language Family
  genre: Esolang
  abstract: |-
    Culmination of attempts to improve upon Befunge.  Seemingly everything
    except the kitchen sink was stuffed into it somehow.
  with:
  - Befunge Mailing List Working Group
  inception-date: 1998
  computational-class: shown Turing-complete
  influences:
  - Befunge-93
  - Befunge-97
  notable: true
  sample: |
    >>#v?v
    ^,A' <
     ^ C'
        T
     ^ <<
        G
        '
  quotation: |-
    Taking programming in new directions... all four of them
  quotation-attribution: |-
    Jason
  "year": |-
    1998
  reference-distribution: Funge-98 distribution
  implementations:
  - FBBI

FBBI:
  type: Language Implementation
  reference: false
  in-distribution: FBBI distribution
  license: BSD
  host-language: ANSI C
  implementation-type: interpreter


Gemooy: 
  type: Programming Language
  genre: Esolang
  abstract: "\nGemooy is really just a two-dimensional bagatelle of sorts; it\
    \ combines features from\n[[2-ill]] and [[Etcha]], and adds self-modification.\
    \ It came about when I noticed\nthe tape-related semantics of 2-ill were essentially\
    \ the same as those of\n[[BitChanger]].\n\n(Information on this language is\
    \ only available on the esowiki for now.)\n  "
  inception-date: Dec 2, 2010
  computational-class: believed Turing-complete
  implementations:
  - tc.catseye.yoob.gemooy
  influences:
  - 2-ill
  - Etcha
  sample: "%### # ###   # #   ### # ###   # #   ### # ###@\n\n   @    @#     \
    \    @\n  @      @          @\n @@\n@                   @\n    $         @#\
    \ # @\n             #      @\n            #\n       @   @\n                \
    \    @\n         \n       @\n      #\n     #\n    @\n    @    @\n     @# @\n\
    @        @\n         @\n  @     @#@\n"
  has-reference-distribution: false

tc.catseye.yoob.gemooy:
  type: Language Implementation
  in-distribution: yoob distribution
  license: Public Domain
  implementation-type: interpreter
  host-language: Java


Kangaroo Iceberg:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Kangaroo Iceberg was a short-lived attempt to pare down Tamerlane
    to something implementable, and implement it.  Although it got a fair ways
    along (e.g. the parser for graphs seems to be complete, I lost interest
    in it at the time, and put off finishing it indefinitely.
    
    Now, the challenge will be reconstructing the language from the partial
    implementation and notes that I left behind...
  failure: true
  influences:
  - Tamerlane
  inception-date: Jul 2004
  reference-distribution: Kangaroo Iceberg distribution
  implementations:
  - kiceberg

kiceberg:
  type: Language Implementation
  in-distribution: Kangaroo Iceberg distribution
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: ANSI C
  broken: true


Kelxquoia: 
  type: Programming Language
  genre: Esolang
  abstract: "\nKelxquoia is another remotely fungeoid language, this one self-modifying\
    \ \u2014 in fact,\nself-destroying.  As instructions are executed, they are\
    \ erased.  In order to execute\nindefinitely, new instructions of some sort\
    \ must be created.\nLuckily the language provides as its main data-manipulation\
    \ facility, grid-rewriting,\nwhich can be used to restore instructions that\
    \ were previously erased after execution.\n\n(Information on this language is\
    \ only available on the esowiki for now.)\n  "
  inception-date: Dec 23, 2010
  computational-class: believed Turing-complete
  esowiki: Kelxquoia
  sample: " >+-0 0*+-1*/+-?*-R*- *+-?*-R*-?*/v\n RRRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRR\n\
    $>+-0 0*+-1*/+-?*-R*- *+-?*-R*-?*/v\n    ' '   '       '  '      '   \n    \
    \         '         '  '     \n ^      /*?-*P-*?-+*?-*P-* -+     <\n P     \
    \ PPPPPPPPPPPPPPPPPP PP     P\n ^      /*?-*P-*?-+*?-*P-* -+     <\n\n 00 00\
    \ 00 00\n"
  has-reference-distribution: false


Maentwrog:
  type: Programming Language
  genre: Pedagogical language
  esowiki: Maentwrog
  summary: A simple RPN-calculator-based language
  abstract: |-
    Maentwrog is an RPN-calculator-turned-FORTH-interpreter, which
    probably counts as Chris Pressey's first proper programming language.
    It was implemented on his Amiga 500 in 1993, then lost and unearthed
    multiple times.  It is hardly remarkable, save that it spawned [[Befunge-93]].
  commentary: |-
    There are no extant example programs from the time the language was first
    implemented — I tried writing the Sieve of Eratosthenes in it once,
    but never got it to work, probably because `==` was not
    implemented correctly.  Recently, example programs and a description of the
    language (which has become the provisional spec) have been provided by
    Marinus — thanks Marinus!
    
    Maentwrog is the name of a town in Wales, but the usage of its name
    for this language came via Douglas Adams' "The Meaning of Liff",
    wherein it is defined thusly:
    "MAENTWROG (n. Welsh) Celtic word for a computer spelling mistake."
  etymology:
  - place name
  - welsh
  sample: |-
    GO 1 2 CLREOL CENTRE "Enter... the Stupid Guard." 2
    GO 1 3 CLREOL
    PAUSE 70
    GO 76 19
    PRINT "0"
    PAUSE 20
    DO 20
        LF PRINT " " LF LF PRINT "0" PAUSE 5;
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1993
  computational-class: known not Turing-complete
  implementations:
  - maentw.c
  reference-distribution: Maentwrog distribution

maentw.c:
  type: Language Implementation
  in-distribution: Maentwrog distribution
  license: Freely Redistributable
  reference: yes
  implementation-type: interpreter
  host-language: ANSI C


Mascarpone:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Mascarpone is a self-modifying language able to alter the meta-circular
    interpreter which defines it, like its predecessor Emmental.  Unlike Emmental
    however, in Mascarpone interpreters are first-class objects, making the
    job of reflective interpreter-modification quite a bit cleaner and richer.
  inception-date: Dec 10, 2007
  computational-class: believed Turing-complete
  etymology:
  - dairy product
  - italian
  influences:
  - Emmental
  sample: |
    v['[/''/']v*]v*'?<^v[/?/<]v*'S<[>!]v*'F<^[]v*1'p'kS'kF.
  significant: true
  quotation: |-
    You are lost in a twisty little maze of meta-circular intepreters, all alike
  quotation-attribution: |-
    "Colossal Cave", Crowther and Woods
  reference-distribution: Mascarpone distribution
  implementations:
  - mascarpone.hs

mascarpone.hs:
  type: Language Implementation
  in-distribution: Mascarpone distribution
  license: BSD
  reference: yes
  implementation-type: interpreter
  host-language: Haskell


MDPN:
  type: Programming Language
  genre: Metalanguage
  acronym-for: Multi-Directional Pattern Notation
  abstract: |-
    MDPN is a meta-language for describing multi-directional and
    multi-dimensional languages.
  inception-date: 1999
  etymology:
  - acronym
  sample: |2
      Box ::= "+" {"-"}^(w) r(-90) "+" "||" {"|"}^(h) r(-90)
              "+" {"-"}^(w) r(-90) "+" "||" {"|"}^(h) r(-90)
  reference-distribution: MDPN distribution


"'N-DCNC":
  type: Programming Language
  genre: Joke language
  abstract: |-
    'N-DCNC was my entry for the 2000 Esoteric Awards ('Essies')
    It is based on a conspiracy theory involving
    UFOs and a 5-member boy band, or something.
  entered-in:
  - Esoteric Awards 2000
  inception-date: Oct 2000
  sample: |
    4*5+2/2,(9*`c)+1
  reference-distribution: "'N-DCNC distribution"
  implementations:
  - ndcnc.pl
  - ndcnc.bf

ndcnc.pl:
  type: Language Implementation
  reference: true
  license: Unknown license
  implementation-type: interpreter
  host-language: Perl

ndcnc.bf:
  type: Language Implementation
  license: Unknown license
  implementation-type: interpreter
  host-language: Befunge-93
  broken: true


"noit o' mnain worb":
  type: Programming Language
  genre: Esolang
  quotation: |-
    Under pressure
  quotation-attribution: |-
    Queen
  abstract: |-
    noit o' mnain worb is a probabilistic particle automaton that
    uses pressure between randomly moving particles to approximate the behaviour
    of circuits.  It can approximate computation with these circuits, too, but
    it's so lossy that it has more value as just a neat toy to watch.
    
    (The name of this language contains a *secret message*! Can *you* find it?)
  inception-date: Sep 15, 2000
  etymology:
  - neologism
  - hidden message
  - celtic
  notable: true
  sample: |
    #####         #####
    #   ###########   #
    # . >         < . #
    #   #####v#####   #
    #####   #  ########
            #       >!#
            #v#########
            # #
            ###
  reference-distribution: noit o' mnain worb distribution
  implementations:
  - worb.pl
  - tc.catseye.yoob.worb

worb.pl:
  type: Language Implementation
  in-distribution: noit o' mnain worb distribution
  license: BSD
  reference: yes
  implementation-type: interpreter
  host-language: Perl

tc.catseye.yoob.worb:
  type: Language Implementation
  in-distribution: yoob distribution
  license: Public Domain
  implementation-type: interpreter
  host-language: Java


REDGREEN:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: |-
    REDGREEN is a cellular automaton that simulates a little
    "physical world", much like [[RUBE]].
  computational-class: shown Turing-complete
  etymology:
  - television program
  influences:
  - RUBE
  sample: |2
                                       # #
                     ......            # #
                                       #  ~                      #
                                       #######################   #
                                      %#                         #
                           . . .      T #####                    #
                                      ###   #  :                 #
                                            #                    #
                                            #  .                 #
                                            #                    #
                                            #                    #
                                            #  .                 #
                                            #                    #
                                            #                    #
    >>>>>>>>>>>>>>>##<<<<<<<<<<<<<<<<<############################
                                                    %
                                                    T
  inception-date: 1998
  implementations:
  - redgreen.alp
  reference-distribution: REDGREEN distribution

redgreen.alp:
  type: Language Implementation
  reference: true
  in-distribution: REDGREEN distribution
  license: BSD
  implementation-type: formal description
  host-language: ALPACA


RUBE:
  type: Programming Language
  genre: Esolang
  abstract: |-
    RUBE is an esoteric programming language in tribute to Rube Goldberg,
    with bulldozers pushing around numbered crates, knocking them together to
    perform computations.  It is based on a variant of a cellular automaton called
    a *bully automaton*, where certain state changes canforce other state changes
    to occur elsewhere in the playfield.
  basis-for-game: true
  inception-date: ca Jul 10, 2007
  etymology:
    - masculine given name
    - acronym
  notable: true
  sample: |2
      0a21646c726f77202c6f6c6c6548
    , :::::::::::::::::::::::::::: ,
     )
     ==============================
    F
                                   O F
                                   c
                                   =
  reference-distribution: RUBE distribution
  implementations:
  - rube.c

rube.c:
  type: Language Implementation
  in-distribution: RUBE distribution
  reference: true
  license: Freely Redistributable
  implementation-type: interpreter
  host-language: ANSI C


Sally:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Sally is a cute but naive little functional language with a minimal syntax,
    a strict type system, and some unusual rules for parameters and return values.
  tagline: |-
    upside-down FORTH
  inception-date: 2000
  etymology:
  - feminine given name
  sample: |
    stdlib
    int factorial int if $1 mul $1 factorial sub $1 1 1
    int main int factorial $1
  reference-distribution: Sally distribution
  implementations:
  - sally2c

sally2c:
  type: Language Implementation
  in-distribution: Sally distribution
  reference: true
  license: BSD
  implementation-type: compiler
  source-language: Sally
  host-language: ANSI C
  target-language: ANSI C


SMETANA:
  type: Programming Language
  genre: Esolang
  esowiki: SMETANA
  acronym-for: Self-Modifying Extremely Tiny AutomatoN Application
  summary: A pathological little self-modifying language
  abstract: |-
    SMETANA is a pathological little self-modifying language with only two
    possible operations: Go to step *n*, and Swap steps *n* and *m*.
    It has inspired a few variants and developments, notably a proof that
    despite its minimalism, it is finite-automata-complete; it is also the
    (great-?)grandfather of [[SMITH]].
  etymology:
  - dairy product
  - russian
  - surname
  sample: |-
    Step 1. Swap step 1 with step 2.
    Step 2. Go to step 2.
    Step 3. Go to step 1.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1994
  computational-class: known not Turing-complete
  notable: true
  reference-distribution: SMETANA distribution
  implementations:
  - smetana.pl
  - tc.catseye.yoob.smetana
  online-implementations:
  - 'http://catseye.tc/gallery/esolangs/yoob/'

smetana.pl:
  type: Language Implementation
  in-distribution: SMETANA distribution
  license: Public Domain
  reference: yes
  implementation-type: interpreter
  host-language: Perl

tc.catseye.yoob.smetana:
  type: Language Implementation
  in-distribution: yoob distribution
  license: Public Domain
  implementation-type: interpreter
  host-language: Java


SMITH:
  type: Programming Language
  genre: Esolang
  esowiki: SMITH
  acronym-for: Self-Modifying Indecent Turing Hack
  summary: An assembly-like language with no jumps whatsoever
  quotation: How many nights and weird mornings can this go on?
  quotation-attribution: Hunter S. Thompson
  abstract: |-
    SMITH is a self-modifying assembly-like language which completely lacks
    any kind of jump instructions *whatsoever*.  Despite this handicap, it
    appears to be Turing-complete.
  etymology:
  - surname
  sample: |-
    MOV R0, 10
    MOV R2, 0
    SUB R2, 1
    MOV R[R0], "Hello, world!"
    MOV TTY, R[R0]
    SUB R0, R2
    MOV R1, R0
    SUB R1, 23
    NOT R1
    NOT R1
    MUL R1, 8
    COR +1, -7, R1
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca July 2000
  computational-class: believed Turing-complete
  notable: true
  significant: true
  reference-distribution: SMITH distribution
  implementations:
  - smith.pl
  influences:
  - SMETANA

smith.pl:
  type: Language Implementation
  in-distribution: SMITH distribution
  reference: yes
  license: BSD
  implementation-type: interpreter
  host-language: Perl


Strelnokoff:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Strelnokoff is a non-deterministic imperative programming language.
    Despite this apparent handicap, it appears to be Turing-complete (thanks
    to a short-circuiting multiplication operator,) but a critical feature (arrays)
    has never yet been implemented.  The name "Strelnokoff" was taken from
    a fictional brand of vodka featured in a mock advertisement on the television
    show [[SCTV]].
  computational-class: believed Turing-complete
  etymology:
  - surname
  - fictional
  - television show
  sample: |
    REM HELLO WORLD IN STRELNOKOFF
    REM CHRIS PRESSEY MARCH 24 2001
    X = (X / X) * X + (X = 0) * (T =  0) * (PRINT CHAR 'H' - 'H' +  1)
    X = (X / X) * X + (X = 0) * (T =  1) * (PRINT CHAR 'e' - 'e' +  2)
    X = (X / X) * X + (X = 0) * (T =  2) * (PRINT CHAR 'l' - 'l' +  3)
    X = (X / X) * X + (X = 0) * (T =  3) * (PRINT CHAR 'l' - 'l' +  4)
    X = (X / X) * X + (X = 0) * (T =  4) * (PRINT CHAR 'o' - 'o' +  5)
    X = (X / X) * X + (X = 0) * (T =  5) * (PRINT CHAR ',' - ',' +  6)
    X = (X / X) * X + (X = 0) * (T =  6) * (PRINT CHAR ' ' - ' ' +  7)
    X = (X / X) * X + (X = 0) * (T =  7) * (PRINT CHAR 'w' - 'w' +  8)
    X = (X / X) * X + (X = 0) * (T =  8) * (PRINT CHAR 'o' - 'o' +  9)
    X = (X / X) * X + (X = 0) * (T =  9) * (PRINT CHAR 'r' - 'r' + 10)
    X = (X / X) * X + (X = 0) * (T = 10) * (PRINT CHAR 'l' - 'l' + 11)
    X = (X / X) * X + (X = 0) * (T = 11) * (PRINT CHAR 'd' - 'd' + 12)
    X = (X / X) * X + (X = 0) * (T = 12) * (PRINT CHAR '!' - '!' + 13)
    X = (T = X) * 0 + (X > T) * X REM RESET FLAG
    T = (X / X) * X + (X = 0) * T REM INCREMENT TICK
  inception-date: Apr 2001
  reference-distribution: Strelnokoff distribution

strelnokoff.pl:
  type: Language Implementation
  in-distribution: Strelnokoff distribution
  reference: yes
  license: BSD
  implementation-type: interpreter
  host-language: Perl


Tamerlane:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Tamerlane is a multi-paradigmatic programming language, unimplemented
    and possibly unimplementable. One of its core execution mechanisms is the
    traversing of a graph (representing the program)\nwhile rewriting that same
    graph.
  inception-date: Aug 2000
  etymology:
  - masculine given name
  sample: |
    Point-A: 1 Point-B,
    Point-B: 1 Point-C,
    Point-C: 1 Point-A.
    ?- 1 Point-A -> 0 Point-A @ Point-A
  reference-distribution: Tamerlane distribution


Treacle:
  type: Programming Language
  genre: Experimental language
  abstract: |-
    Treacle is an experimental compiler-definition language based on
    _context rewriting_, an expressive variant of term rewriting that generalizes
    the forest-rewriting used by its predecessor [[Arboretuum]].  In context rewriting,
    a separation is made between _names_ and _variables_, and patterns may contain
    _holes_ inside which subpatterns may match at any depth.
  computational-class: believed Turing-complete
  inception-date: Apr 12, 2008
  etymology:
  - british
  - condiment
  influences:
  - Arboretuum
  sample: |-
    XXX needs sample here
  reference-distribution: Treacle distribution
  implementations:
  - treacle.scm

treacle.scm:
  type: Language Implementation
  in-distribution: Treacle distribution
  license: Unknown license
  reference: true
  host-language: Scheme
  implementation-type: interpreter


Velo: 
  type: Programming Language
  genre: Esolang
  abstract: |-
    Velo is a vaguely Ruby-inspired "scripting" language which unifies
    strings with code blocks, and scripts with object classes.  Curly braces
    delimit string literals, and there is no difference between a string literal
    and a block of code given to, say, an `if` statement.  Any given script is
    an object, which inherits from the root object in delegation-OO style.
  computational-class: believed Turing-complete
  inception-date: July 14, 2012
  influences:
  - Ruby
  sample: |-
    yes = {IO.print {Yes}}
    no = {IO.print {No}}
    if ({X}.equals {Y}), yes, no
  reference-distribution: Velo distribution

velo.rb:
  type: Language Implementation
  in-distribution: Velo distribution
  license: Unknown license
  reference: true
  host-language: Ruby
  implementation-type: interpreter


Version:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Version is an imperative programming language that uses _ignorance-spaces_
    for flow control; all  instructions which match the current ignorance pattern
    are ignored during execution.
  inception-date: Sep 2001
  sample: |
    START: ROOM = "VALLEY|BROOK|GLADE"
    CONT: IGNORE = ROOM
    VALLEY: OUTPUT = "You are standing in a valley."
    HILL: OUTPUT = "You are on top of a hill."
    BROOK: OUTPUT = "You are by a brook."
    GLADE: OUTPUT = "You are standing in a sun-dappled glade."
    ROOM: OUTPUT = EOL
    ROOM: DIR = CHOP INPUT
    ROOM: IGNORE = DIR
    ROOM: MASK = "VAPOURS"
    N: CAT = "|N"
    S: CAT = "|S"
    E: CAT = "|E"
    W: CAT = "|W"
    ROOM: IGNORE = MASK
    N: ROOM = "VALLEY|BROOK|GLADE"
    S: ROOM = "HILL|BROOK|GLADE"
    E: ROOM = "VALLEY|HILL|BROOK"
    W: ROOM = "VALLEY|HILL|GLADE"
    LASTLY: IGNORE = "START"
  reference-distribution: Version distribution
  implementations:
  - version.pl

version.pl:
  type: Language Implementation
  in-distribution: Version distribution
  license: BSD
  reference: true
  host-language: Perl
  implementation-type: interpreter


Wierd:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Wierd is a language, inspired somewhat by Befunge-93, where instructions
    are not determined by the symbols in a sequence of symbols, but by the *bends*
    in a sequence of symbols.
  authors:
  - Chris Pressey
  - John Colagioia
  - Ben Olmstead
  computational-class: believed Turing-complete
  inception-date: 1997
  etymology:
  - typo
  influences:
  - Befunge-93
  notable: true
  sample: |
    *
     *
      *
       *
      * *  **
     *   ** *
      **     **
        *      *
        *     *
        *     *
        *      *
        *     **
        *    *
        * ** *
        **  *
  sample-credit: Milo van Handel
  reference-distribution: Wierd distribution
  implementations:
  - wierd.c
  - wierd-milo.c

wierd.c:
  type: Language Implementation
  in-distribution: Wierd distribution
  author: John Colagioia
  license: Unknown license
  implementation-type: interpreter
  host-language: ANSI C

wierd-milo.c:
  type: Language Implementation
  in-distribution: Wierd distribution
  author: Milo van Handel
  license: Unknown license
  implementation-type: interpreter
  host-language: ANSI C


Ypsilax:
  type: Programming Language
  genre: Esolang
  abstract: |-
    Ypsilax is a non-deterministic, reflective, two-dimensional grid-rewriting
    language.  Rewriting rules look for patterns in the grid and replace them
    with other patterns.  These rules are themselves represented by patterns
    in the grid, and therefore rules can match and rewrite other rules.
  computational-class: believed Turing-complete
  inception-date: Aug 2001
  etymology:
  - neologism
  sample: |
    (      )  (      )
      #            #
      # ###    ### #
      #            #
   
        ###   ###
   
        #      #
        #      #
        #    ###
  reference-distribution: Ypsilax distribution
  implementations:
  - ypsilax.pl
  - tc.catseye.yoob.ypsilax

ypsilax.pl:
  type: Language Implementation
  in-distribution: Ypsilax distribution
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: Perl

tc.catseye.yoob.ypsilax:
  type: Language Implementation
  in-distribution: Ypsilax distribution
  license: BSD
  implementation-type: interpreter
  host-language: Java


ZOWIE:
  type: Programming Language
  genre: Esolang
  abstract: |-
    ZOWIE is a machine-like language in which all operations *including
    structured control flow* are memory-mapped.  Control flow is structured in
    the sense of structured programming -- the programmer never deals with
    `goto`s, or offsets or labels of any kind.  Instead, the program writes to
    a memory location to mark the beginning or end of a loop or conditional.
  inception-date: Dec 29, 2009
  computational-class: shown Turing-complete
  influences:
  - BitChanger
  sample: |
    MOV R10, 90
    MOV R1, R1
    MOV R0, R10
    MOV R8, R10
    MOV R5, 1
    MOV R10, R8
    MOV R8, R10
    MOV R5, 64
    MOV R3, R8
  reference-distribution: ZOWIE distribution
  implementations:
  - zowie.py

zowie.py:
  type: Language Implementation
  reference: true
  in-distribution: ZOWIE distribution
  license: Public Domain
  host-language: Python
  implementation-type: interpreter



###---### following languages need some massaging ###---###
###---### following languages need some massaging ###---###
###---### following languages need some massaging ###---###
###---### following languages need some massaging ###---###
###---### following languages need some massaging ###---###


ETHEL:
  type: Programming Language
  genre: DSL
  abstract: "\nA language specifically for expressing quantity surveying\n(materials\
    \ estimating) formula and procedures,\ndesigned for Star Building Materials.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1020
  etymology:
    "nametag": |-
      acronym
  "implemented": !!null |-
    null
  "inception": |-
    1998
  "name": |-
    ETHEL
  "year": |-
    1998
  has-reference-distribution: false


Shelta:
  type: Programming Language
  genre: Esolang
  abstract: "\nShelta is an extremely minimal Forth-like language with barely\
    \ any semantics;\nit relies on inline machine code to be considered anywhere\
    \ near Turing-Complete.\nIn the spirit of compilers for languages such as [[FALSE]]\
    \ and [[brainfuck]],\na Shelta-to-8086 compiler was implemented (with help from\
    \ Ben Olmstead) in less than\n512 bytes of 80286 machine code.\nWhat's more,\
    \ it's also been bootstrapped \u2014 that is to say,\na Shelta compiler was\
    \ written in Shelta, which was compiled with the\noriginal compiler, and then\
    \ compiled again with the resulting compiler,\nproducing a wholly self-hosted\
    \ executable!\n  "
  with:
  - Ben Olmstead
  bootstrapped: true
  "day": |-
    0601
  etymology:
  - spoken language
  - celtic
  "ximplementations":
    "implementation":
    - "host-language": |-
        x86 assembly
      "name": |-
        shelta
      "reference": |-
        yes
      "target-language": |-
        x86 executable
      "type": |-
        compiler
    - "host-language": |-
        Shelta
      "name": |-
        sheltas
      "target-language": |-
        x86 executable
      "type": |-
        compiler
  "name": |-
    Shelta
  "project": |-
    shelta
  sample: |
    [ `Hello, _32 `world! _13 _10 ] \15 outs \0 halt
  "year": |-
    1999
  reference-distribution: Shelta distribution


Bear Food:
  type: Programming Language
  genre: Esolang
  abstract: "\nBear Food was a horrible language defined by an interpreter that\
    \ evolved\n(no... let's be honest, it *devolved*) from a small\npiece of example\
    \ code showing how to parse and intepret\na simple reverse-polish notation language.\
    \  This same example\ncode also took a very divergent line of evolution, eventually\n\
    becoming the programming language [[Var'aq]].\n  "
  "day": |-
    1201
  "failure": !!null |-
    null
  implementations:
  - bearfood.pl
  "name": |-
    Bear Food
  quotation: |-
    liquid insanity from Hell
  "year": |-
    1999
  has-reference-distribution: false

bearfood.pl:
  type: Language Implementation
  reference: true
  license: Unknown license
  implementation-type: interpreter
  host-language: Perl
  broken: true


Squishy2K:
  type: Programming Language
  genre: Esolang
  abstract: "\nSquishy2K is a language which is a hybrid of string rewriting\n\
    and finite state automata; as an added twist, it also lets program\nstates serve\
    \ as functions.  It was based largely on an earlier grammar-based\nlanguage\
    \ called SQUISHY, taking also some ideas from the language [[Thue]].\n\nThe\
    \ original SQUISHY was conceived sometime around 1998, but is now\nlost.  Because\
    \ it was based largely on EBNF, the author wanted to name\nit Wirth, but the\
    \ name SQUISHY was proposed and (somewhat unfortunately)\nstuck.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0901
  implementations:
  - squishy2k.pl
  "name": |-
    Squishy2K
  "project": |-
    squishy2k
  sample: |
    * main { start many finish? "Hello, world!"! }
  "year": |-
    2000
  reference-distribution: Squishy2K distribution

squishy2k.pl:
  type: Language Implementation
  in-dstribution: Squishy2K distribution
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: Perl


Hunter:
  type: Programming Language
  genre: Esolang
  abstract: "\nHunter is a language I designed for the Esoteric Awards (\"Essies\"\
    ).\nIts abstract starts out like this:\n\n> It is perceived that one of the\
    \ biggest problems in maintaining\n> interest in programming is the above linear\
    \ growth of boredom\n> compared to the usefulness of the program, resulting\
    \ in an\n> acute loss of enthusiasm on the part of the programmers and\n> ultimately\
    \ the abandonment of the software...\n  "
  "day": |-
    0920
  etymology:
  - masculine given name
  implementations:
  - hunter.pl
  sample: |
    ##################
    #   1#2#         #
    # #### #         #
    #      #         #
    # ######    M    #
    #     M#         #
    #+######         #
    #     !#         #
    ##################
    *12+>3
    *21+>3
  quotation: |-
    maze-space rewriting with authentic inter-rodent communication
  "year": |-
    2000
  reference-distribution: Hunter distribution

hunter.pl:
  type: Language Implementation
  in-dstribution: Hunter distribution
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: Perl


ILLGOL:
  type: Programming Language
  genre: Joke language
  abstract: "\nJoke languages which parody the sort of language designed by the\
    \ sheer fact\nthat a compiler for it has been hacked together.\n  "
  "day": |-
    0601
  "descendants":
    "descendant":
    - |-
      Illgola-2
    - |-
      Illberon
    - |-
      Illgol##
  etymology:
    "nametag": |-
      parody
  "ximplementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        ILLGOL.COM
      "reference": |-
        yes
      "target-language": |-
        x86 executable
      "type": |-
        compiler
  "inception": |-
    2000
  "name": |-
    ILLGOL
  "project": |-
    illgol
  sample: |
    NB eh.ill
    10 *f = { print str(#0), EoL };
    20 do f(1);
    30 don't f;
    40 do f(2);
    50 reinstate f;
    60 do f(3);
    FIN
  "year": |-
    2001
  reference-distribution: illgol


Opus-2:
  type: Abstract Artlang
  abstract: "\nOpus-2 is not a programming language, but rather, an abstract artlang\
    \ (i.e.,\na conlang designed independently from any conception of society.)\n\
    The sole design principle was to entirely eliminate word order.\n  "
  "day": |-
    0701
  "name": |-
    Opus-2
  "project": |-
    opus-2
  sample:
    "mode": |-
      xhtml
    "table":
      "style": |-
        text-align: center;
      "tr":
      - "td":
          "i": |-
            pale green
      - "td":
          "i": |-
            Eb, trombone, forte
      - "td":
          "i": |-
            leaning 40 degrees left (sudden)
      - "td":
          "i": |-
            C, tubular bells, piano
      - "td":
          "i": |-
            mothballs (gentle whiff)
  "significant": !!null |-
    null
  "year": |-
    2001
  reference-distribution: Opus-2 distribution


Sbeezg:
  type: Programming Language
  genre: Esolang
  abstract: "\nSbeezg is a syntactically very simple language that attempts to\
    \ take the single-assignment concept\nto a logical extreme.\n  "
  "day": |-
    0101
  etymology:
    "nametag": |-
      neologism
  implementations:
  - sbeezg.erl
  sample: |
    f={a,b|i=*is;s=*pred;p=*print;g=p(*beer);h=s(a);
       ln={x,m|z=x|x};lg={y,n|q=n(y,n)|y};j=i(h,0,ln,lg);
       k=j(h,b)|a};l=f(99,f)
  "year": |-
    2002
  reference-distribution: Sbeezg distribution

sbeezg.erl:
  type: Language Implementation
  in-distribution: Sbeezg distribution
  reference: true
  license: BSD
  implementation-type: interpreter
  host-language: Erlang


GraNoLa/M:
  type: Programming Language
  genre: Esolang
  acronym-for: GRAph-NOde LAnguage (possibly for Machines)
  abstract: "\nGraNoLa/M is a Graph-Node-based Language (possibly for Machines.)\n\
    It was one of my submissions for the Esoteric Awards.\nNot unlike Tamerlane,\
    \ its execution model involves both\ntraversing and rewriting a graph at the\
    \ same time.\n  "
  "day": |-
    0601
  etymology:
    "nametag": |-
      acronym
  influences:
  - Tamerlane
  "name": |-
    GraNoLa/M
  "project": |-
    granolam
  sample: |
    a=^sajalom(b=^#d(c=^bimodang(^a))d(e=^#cthulhu(f=^uwaming(g=^ubewic()))))
  "year": |-
    2002
  reference-distribution: GraNoLa/M distribution
  implementations:
  - granolam.erl

granolam.erl:
  type: Language Implementation
  in-distribution: GraNoLa/M distribution
  reference: true
  license: Unknown license
  implementation-type: interpreter
  host-language: Erlang


Beturing:
  type: Programming Language
  genre: Esolang
  abstract: "\nBeturing is a \"Befunge-flavoured\" language for describing Turing\
    \ machines; both the tape and\nthe finite control are laid out two-dimensionally.\
    \  In addition, the finite control must be\nexpressed as a planar graph (no\
    \ edge representing a transition may cross any other edge.)\nIt was devised\
    \ this way as a test of the so-called \"wire-crossing problem\".\nIt turns out\
    \ that there are universal Turing machines with finite controls that are\nplanar\
    \ graphs, so Beturing is Turing-complete.\n  "
  "day": |-
    1020
  "demonstrated-turing-complete": !!null |-
    null
  etymology:
    "nametag": |-
      portmanteau
  "ximplementations":
    "implementation":
      "host-language": |-
        Lua
      "name": |-
        beturing.lua
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Beturing
  "project": |-
    beturing
  sample: |
    # D(40, 4)
    # @(40, 4)
    $bbab$
    # C(0, 0)
    # @(0, 0)
     . . . . . .
    *v*<*<*<*>*v
    aa .ab . .aa .
    >/*>./*^*^</*v
    bb .ba . .bb .
    >/*^./*^*^</*v
    $$ .$$ . .$$ .
    >/*^</*>*^.@*v
             . . .
    *@      *^*<*<
  "year": |-
    2005
  reference-distribution: Beturing distribution


Bhuna:
  type: Programming Language
  genre: Production language
  abstract: "\nBhuna is a small, garbage-collected language with a simple\nsyntax,\
    \ closures, inferred types, lightweight processes, and support for UTF-8\nsource\
    \ code.  It was implemented partly to see how closely I could match\nthe performance\
    \ of Lua's interpreter.  It was meant more more as an experimental\nstarting\
    \ point for branching new languages, than as a useful language in and of itself.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1021
  etymology:
    "nametag":
    - |-
      indian
    - |-
      dish
  "ximplementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        bhuna
      "reference": |-
        yes
      "type": |-
        interpreter
  influences:
  - Lua
  "name": |-
    Bhuna
  "project": |-
    bhuna
  sample: |
    Fib = ^ X {
      if X < 2 return 1 else
      return Fib(X - 1) + Fib(X - 2)
    }
    Print Fib(32), EoL
  "year": |-
    2005
  reference-distribution: Bhuna distribution


Xigxag:
  # hmm... well, no.  but for now, yes.
  type: Programming Language
  genre: Esolang
  abstract: "\nXigxag is a simple string-copying automaton that has exponential\
    \ growth almost everywhere\n(i.e. there are only a finite number of initial\
    \ configurations that don't blow up.)\n  "
  "day": |-
    0423
  "ximplementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        xigxag.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "inception": |-
    2001
  "name": |-
    Xigxag
  "project": |-
    xigxag
  sample:
    "mode": |-
      output
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2007
  reference-distribution: Xigxag distribution


Hev:
  type: Programming Language
  genre: Esolang
  abstract: "\nHev is a programming language that attempts to solve the \"central\
    \ problem of\ninfix notation\": how do you allow it without requiring the programmer\
    \ to either\nmemorize precedence tables or litter parentheses everywhere?  Hev\
    \ has a way!\nIn Hev, *all* operators are infix, yet no tiresome memorization\
    \ of any\ndreadful precedence table is required!\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0523
  etymology:
    "nametag": |-
      neologism
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Hev.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Hev
  "project": |-
    hev
  sample: |
    71+8*27,19,29*99,6,37,7,61,47
  "year": |-
    2007
  reference-distribution: Hev distribution



Burro:
  type: Programming Language
  genre: Esolang
  abstract: "\nBurro is a [[brainfuck]]-like programming language whose programs\n\
    form an algebraical _group_ (modulo the equivalence relation of \"computes the\
    \ same function\")\nunder the operation of concatenation.\nThe upshot of this\
    \ is that, for every Burro program, we can find\nan _antiprogram_ which, when\
    \ appended to the program,\nforms a \"no-op\" program which has no effect.\n\
    \nThis is a form of reversible computing, but unlike most reversible languages\n\
    where it is the execution of the program that is \"undone\", in Burro, it is\
    \ the\nprogram itself which is annihiliated by its antiprogram.\n\nBurro 1.0\
    \ was released in fall of 2007, but proved not to form a proper group.\nThis\
    \ shortcoming was rectified in summer of 2010.\n  "
  "day": |-
    0607
  "demonstrated-turing-complete": !!null |-
    null
  etymology:
    "nametag": |-
      spanish
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Burro.lhs
      "reference": |-
        yes
      "type": |-
        interpreter
  "inception": |-
    2005
  influences:
  - brainfuck
  "name": |-
    Burro
  "project": |-
    burro
  sample: |
    !--(--(--(!>/
      >>--(+<<+++++++>/+++>+++++>)<
    >)/
      >>--(+++>+++++>/+++<<<<<+++>)<
    >)/
      >>--(+++>+>/+<<+++>)<
    >)<
  significant: true
  "year": |-
    2010
  reference-distribution: Burro distribution


Cabra:
  type: Programming Language
  genre: Esolang
  abstract: "\nCabra is a (somewhat) formal programming language whose programs\
    \ form an algebraical\n_dioid_ (an idempotent semiring), modulo the equivalence\
    \ relation of \"computes the same function\",\nunder the operations of parallel\
    \ execution (as the additive operator) and sequential composition\n(as the multiplicative\
    \ operator).\n  "
  "day": |-
    1030
  etymology:
    "nametag": |-
      spanish
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        cabra.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  influences:
  - Burro
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Cabra
  "project": |-
    cabra
  sample: |
    (SET 1 + SET 2) * IFSET 1 THEN (IFSET 2 THEN SET 3 ELSE SKIP) ELSE SKIP
  "year": |-
    2007
  reference-distribution: Cabra distribution


You are Reading the Name of this Esolang:
  type: Programming Language
  genre: Esolang
  abstract: "\nYou are Reading the Name of this Esolang is an exploration in\n\
    the design space of programming languages with undecidable elements.\nIts syntax\
    \ is only recursively enumerable:\nthe problem of determining whether or not\n\
    a given string of symbols is a well-formed\nYou are Reading the Name of this\
    \ Esolang program is undecidable.\n  "
  "day": |-
    1101
  "demonstrated-turing-complete": !!null |-
    null
  influences:
  - Spoon
  "name": |-
    You are Reading the Name of this Esolang
  "project": |-
    urreading
  sample: |
    001000000[0010000000111001000011]11100100001[0]
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2007
  reference-distribution: You are Reading the Name of this Esolang distribution


Emmental:
  type: Programming Language
  genre: Esolang
  abstract: "\nEmmental is a self-modifying programming language.  It is defined\
    \ in terms\nof a meta-circular interpreter, and this meta-circular interpreter\
    \ provides\nan operation that redefines operations of the meta-circular interpreter.\
    \  In\nfact, this mechanism is required for Emmental to be Turing-complete.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1111
  etymology:
    "nametag":
    - |-
      dairy
    - |-
      swiss
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        emmental.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Emmental
  "project": |-
    emmental
  sample: |
    ;#58#126#63#36!;#46#36#!;#0#1!;#0#2!;#0#3!;#0#4!;#0#5!;#0#6!;#0#7!#0#33#111#108#108#101#72$
  "year": |-
    2007
  reference-distribution: Emmental distribution


Didigm:
  type: Programming Language Family
  genre: Esolang
  abstract: "\nDidigm is a reflective cellular automaton: the transition rules\
    \ for the\nautomaton are defined by forms in the very playfield governed by\
    \ those transition rules.\n  "
  "day": |-
    1120
  etymology:
    "nametag": |-
      neologism
  "name": |-
    Didigm
  "project": |-
    didigm
  sample: |
    3333333333333
    3002300230073
    3111311132113
    3311321131573
    3111311131333
    3333333333333
    =F3
    ,
    =F1
    111111111111111
    111111131111111
    111111111111574
    111111111111333
    311111111111023
    111111111111113
  quotation: |-
    Didigm = ALPACA + Ypsilax
  "year": |-
    2007
  reference-distribution: Didigm distribution


Iphigeneia:
  type: Programming Language
  genre: Pedagogical language
  abstract: "\nIphigeneia is a toy programming language which contains features\
    \ from both\nimperative programming (assignments to mutable variables, `while`\
    \ loops,)\nand functional programming (immutable name bindings,\nScheme-style\
    \ \"named `let`\" loops.)\nIt was originally intended as a testbed for\nalgorithms\
    \ that convert programs between the two forms.\n  "
  "day": |-
    1120
  etymology:
    "nametag":
    - |-
      classical greek
    - |-
      mythological
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        iphi
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Iphigeneia
  "project": |-
    iphi
  sample: "var a in a :=\n    let c = 5 in let d = 1 in\n        loop\n\t    if\
    \ c = 0 then\n\t        d\n\t    else\n\t        let d = d * c in\n\t      \
    \      let c = c - 1 in\n\t\t        repeat\n"
  "year": |-
    2007
  reference-distribution: Iphigeneia distribution


Larabee:
  type: Programming Language
  genre: Esolang
  abstract: "\nLarabee is an assembly-like programming language, with Scheme-like\
    \ syntax,\nthat borrows the notion of branch prediction from computer architecture\n\
    and abuses it, creating a path that leads only to existential angst and self-destruction.\n\
    \  "
  "day": |-
    0110
  etymology:
    "nametag": |-
      television
  "ximplementations":
    "implementation":
      "host-language": |-
        Scheme
      "name": |-
        larabee.scm
      "reference": |-
        yes
      "type": |-
        interpreter
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Larabee
  "project": |-
    larabee
  sample: |-
    (store (input) (input)
      (store (input) (input)
        (label loop
          (store (input) (op * (fetch (input)) (fetch (input)))
            (store (input) (op - (fetch (input)) (input))
              (test (op > (fetch (input)) (input))
                (goto loop) (print (fetch (input)))))))))
  "year": |-
    2008
  reference-distribution: Larabee distribution


Arboretuum:
  type: Programming Language
  genre: Experimental language
  abstract: "\nArboretuum is an experimental language based on _forest-rewriting_,\n\
    a variant of tree-rewriting in which multiple trees are rewritten simultaneously.\n\
    The language was intended for specifying compilers, with each tree representing\n\
    a major compiler data structure (AST, symbol table, output buffer, etc.,)\n\
    however, this idea was not entirely successful.  Regardless, Arboretuum is\n\
    Turing-complete, as tree-rewriting is simply a special case of forest-rewriting.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0301
  etymology:
    "nametag":
    - |-
      latin
    - |-
      portmanteau
  "ximplementations":
    "implementation":
      "host-language": |-
        Scheme
      "name": |-
        forest-rewriter.scm
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Arboretuum
  "project": |-
    arboretuum
  sample: |-
    (
      (
        (ast:   (let a 4 (+ 3 (* a 3))) )
        (stab:  eot)
        (out:   halt)
      )
      (
        ((ast:  (let #(n sym) #(v) #(expr)) => #(expr)            )
         (stab: eot                         => (#(n) #(v) EOT)    ))
        ((ast:  #(n sym)                    => #(v)               )
         (stab: (#(n) #(v) #(tab))          => (#(n) #(v) #(tab)) ))
        ((ast: #(a num)                     => _                  )
         (out: halt                         => (push #(a) halt)   ))
        ((ast: (+ _ _)                      => _                  )
         (out: halt                         => (add halt)         ))
        ((ast: (* _ _)                      => _                  )
         (out: halt                         => (mul halt)         ))
      )
    )
  "year": |-
    2008
  reference-distribution: Arboretuum distribution


Quylthulg:
  type: Programming Language
  genre: Esolang
  abstract: "\nQuylthulg is a programming language with but a single \ncontrol-flow\
    \ construct: `foreach`.  In fact, it \ndoes also have a `goto`, but that can\
    \ only appear \ninside data structures.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1206
  etymology:
    "nametag": |-
      mythological
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name":
        "tool": |-
          no
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Quylthulg
  "project": |-
    quylthulg
  sample: |-
    foreach $n$=:L:[1,2,3|goto$L$] with $a$=1 be +$a$+$n$+ else be abort
  "year": |-
    2008
  reference-distribution: Quylthulg distribution


Unlikely:
  type: Programming Language
  genre: Esolang
  abstract: "\nUnlikely is a programming language that conflates objects with\
    \ continuations,\nand methods with labels.  It exposes program structures as\
    \ objects with\ncommensurate inheritance relationships.  It also takes dependency\
    \ injection to\nthe logical extreme: if some class is used by an object, that\
    \ class *must* be\nspecified when the object is instantiated.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0315
  "ximplementations":
    "implementation":
      "host-language": |-
        Python
      "name":
        "tool": |-
          no
      "type": |-
        static analyzer
  "name": |-
    Unlikely
  "project": |-
    unlikely
  sample: |-
    class Count(Count,Chain,Print,Add) extends Continuation
    
    class CountForever(Count,Chain,Print,Add) extends Program {
      Count c;
      method continue(Passive accumulator) {
        c = new Count(Passive,Count,Chain,Print,Add);
        goto c.continue(new 1(Passive));
      }
    }
    
    class Count() extends Continuation {
      Count c;
      Print p;
      Add a;
      method continue(Passive accumulator) {
        c = new Count(Passive,Count,Chain,Print,Add);
        a = new Add(Passive,Chain);
        a.value = new 1(Passive);
        a.next = c;
        p = new Print(Passive,Chain);
        p.next = a;
        goto p.continue(accumulator);
      }
    }
  "year": |-
    2009
  reference-distribution: Unlikely distribution


# TODO: split up?
Jaccia and Jacciata:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: "\nJaccia and Jacciata are cellular automata inspired by the\n[Announcement\
    \ of Scientific Proof that Slime Molds are\nIntelligent Maze Solvers](http://web.archive.org/web/20020220163303/http://www.riken.go.jp/lab-www/frontier-div/NEWSLETTER/feb2001/ameboid_e.htm).\n\
    Jaccia can solve mazes too, by a similar mechanism (shrinking).\nJacciata builds\
    \ upon this to find the shortest path through a maze, if one exists and is unique.\n\
    \  "
  "day": |-
    0411
  etymology:
    "nametag": |-
      neologism
  "ximplementations":
    "implementation":
    - "host-language": |-
        ALPACA
      "name": |-
        jaccia.alp
      "reference": |-
        yes
      "type": |-
        description
    - "host-language": |-
        ALPACA
      "name": |-
        jacciata.alp
      "reference": |-
        yes
      "type": |-
        description
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Jaccia and Jacciata
  "project": |-
    jaccia
  sample:
    "mode": |-
      output
  "year": |-
    2009
  reference-distribution: Jaccia and Jacciata distribution


Pixley:
  type: Programming Language
  genre: Esolang
  abstract: "\nPixley is a strict subset of R5RS Scheme (or, if you prefer, R4RS\
    \ Scheme),\nsupporting four datatypes (boolean, cons cell, function, and symbol)\
    \ and\na dozen built-in symbols.  The reference implementation of Pixley\nis\
    \ written in 124 lines of Pixley (or, if you prefer, 124 lines of Scheme;\n\
    and if you prefer more Scheme-ly metrics, it consists of 413 instances of\n\
    54 unique symbols in 684 cons cells.)\n  "
  "believed-turing-complete": !!null |-
    null
  "bootstrapped": !!null |-
    null
  "day": |-
    0501
  etymology:
    "nametag":
    - |-
      placename
    - |-
      television
  "ximplementations":
    "implementation":
      "host-language": |-
        Pixley
      "name":
        "tool": |-
          yes
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Pixley
  "project": |-
    pixley
  sample: |-
    (let* ((a (lambda (x y) (cons x y)))) (a (quote foo) (quote ())))
  "year": |-
    2009
  reference-distribution: Pixley distribution


Etcha:
  type: Programming Language
  genre: Esolang
  abstract: "\nEtcha is a two-dimensional descendant of Jeffry Johnston's\n[BitChanger].\
    \  Like BitChanger, it has four instructions;\nunlike BitChanger, its storage\
    \ model is based on turtle graphics, which permits it to be immediately used\
    \ for an\nalternative purpose: graphical composition. Unlike the turtle in LOGO\
    \ however, the turtle in Etcha is an integral part of the\ncomputation, playing\
    \ a role similar to the tape head of a Turing machine.\n  "
  "day": |-
    1004
  "demonstrated-turing-complete": !!null |-
    null
  "ximplementations":
    "implementation":
      "host-language": |-
        Java
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  influences:
  - BitChanger
  "name": |-
    Etcha
  "project": |-
    etcha
  sample:
    "mode": |-
      output
  "year": |-
    2009
  reference-distribution: Etcha distribution


Okapi: 
  type: Programming Language
  genre: Esolang
  abstract: "\nOkapi is a language I designed as an anniversary present for my\
    \ wife(!).\nIn it, the only means of control flow is throwing exceptions, and\
    \ as if this wasn't\nenough, there are two restrictions on exceptions that are\
    \ thrown \u2014 they\nmust be divide-by-zero exceptions, and they must be caught\
    \ in a lexically\nenclosing block.  Nor is there any facility to \"retry\" after\
    \ an exception is caught.\nThe language is nonetheless Turing-complete.\n  "
  "day": |-
    0523
  "demonstrated-turing-complete": !!null |-
    null
  "ximplementations":
    "implementation":
      "host-language": |-
        Python
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "name": |-
    Okapi
  "year": |-
    2010
  has-reference-distribution: false


Whothm: 
  type: Programming Language
  genre: Esolang
  abstract: "\nWhothm is a simple language for describing infinite\ntwo-colour\
    \ bitmapped drawings.\n  "
  "day": |-
    0628
  "ximplementations":
    "implementation":
      "host-language": |-
        Java
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Whothm
  "project": |-
    whothm
  sample: |
    r := (0, 0, 1, 2);
    s := (0, 0, 1, 2);
    XOR := TF/FT;
    
    begin
    r.x += r.w;
    r.x += -1;
    r.w += 1;
    r.h += 1;
    draw r, XOR;
    s.x += s.w;
    s.x += -1;
    s.w += 1;
    s.h += 2;
    draw s, XOR;
    end
  "year": |-
    2010
  reference-distribution: Whothm distribution


Oozlybub and Murphy: 
  type: Programming Language
  genre: Esolang
  abstract: "\nThe name of this language is Oozlybub and Murphy.\nDespite appearances,\
    \ this name refers to a single language.\nThe majority of the language is named\
    \ Oozlybub.\nThe fact that the language is not entirely named Oozlybub is named\
    \ Murphy.\nDeal with it.\n\nFor the sake of providing an \"olde tyme esoterickal\
    \ de-sign\",\nthe language combines several unusual features, including multiple\
    \ interleaved\nparse streams, infinitely long variable names, gratuitously strong\
    \ typing, and\nonly-conjectural Turing completeness.\n  "
  "day": |-
    1201
  "name": |-
    Oozlybub and Murphy
  "project": |-
    oozlybub-and-murphy
  sample: |
    VARIABLES ARE p /p*/, p /q*/.
    dynast(3) <->
      (. do (. if? not? exists/dynast 5 ,then
           create/countably/many/dynasts #myself#, 5 .) .) ,then
      (. for each prime /p*|p/ below #myself#+2 do
           for each prime /q*|q/ below /p*|pp/+1 do
             if? not? exists/dynast /p*|p|p/+/q*|q|q/ ,then
               copy/dynast #myself#, /p*|ppp/, /q*|qqq/ .)
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2010
  reference-distribution: Oozlybub and Murphy distribution


Nhohnhehr: 
  type: Programming Language
  genre: Esolang
  abstract: "\nNhohnhehr is a remotely fungeoid language which explores the design\
    \ space between having\na fixed playfield versus an expandable one.  When the\
    \ instruction pointer reaches the edge of\nthe playfield (the \"room\"), whether\
    \ it wraps around or creates a new room and adjoins it to that\nedge, depends\
    \ on the current _edge mode_ of the program.  New copies of rooms may\nbe rotated\
    \ before being adjoined to existing rooms, but rooms are otherwise immutable.\n\
    \  "
  "can-simulate-some-push-down-automata": !!null |-
    null
  "day": |-
    1208
  "ximplementations":
    "implementation":
      "host-language": |-
        Python
      "name": |-
        nhohnhehr.py
      "type": |-
        interpreter
  "implemented": !!null |-
    null
  "name": |-
    Nhohnhehr
  "project": |-
    nhohnhehr
  sample: |
    +------+
    |    /}|
    |&#/$?@|
    |  / \&|
    |      |
    | {    |
    |\\    |
    +------+
  "year": |-
    2010
  reference-distribution: Nhohnhehr distribution


Wunnel: 
  type: Programming Language
  genre: Esolang
  abstract: "\nWunnel is a two-dimensional language which draws from the\n[[1L]]\
    \ family of languages and incorporates features from [[reMorse]].\nThe name\
    \ is both a play on the pronunciation of \"1L\", and\na recursive portmanteau\
    \ of the words _Wunnel_ and _tunnel_\nwhich is used to describe the long sequences\
    \ of identical instructions (often nops) used in\nWunnel programs to sync up\
    \ remote parts of the program.\n\n(Information on this language is only available\
    \ on the esowiki for now.)\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0213
  "ximplementations":
    "implementation":
      "host-language": |-
        Java
      "name": |-
        WunnelState.java
      "type": |-
        interpreter
  "implemented": !!null |-
    null
  influences:
  - 1L
  - reMorse
  sample: |2
              o   ooo  o


    o
    o
    o
    o         o
    o         o
    o         o
    o         o
    o
    o        o     o
    o         o
    o
    o        o
    o              o
    o        o     o
    o              o

             o
    o oooooooo     o
             o
             o
             o

             o    oooo o
  "year": |-
    2011
  has-reference-distribution: false


Pail: 
  type: Programming Language
  genre: Esolang
  abstract: "\nPail is a programming language based on pairs; just as Lisp stands\
    \ for\nLISt Processing, Pail stands for PAIr Language.\nIts original working\
    \ title was \"Bizaaro[sic]-Pixley\", as it attempts to resemble\n[[Pixley]]\
    \ while turning several concepts on their heads: use pairs instead of lists,\n\
    quote by default instead of eval by default, and allow not just values but also\n\
    names of bindings to be expressed.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0525
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Pail.lhs
      "reference": |-
        yes
      "type": |-
        interpreter
  influences:
  - Pixley
  "name": |-
    Pail
  "project": |-
    pail
  sample: |
    **[*let [
         [cadrg *[#fst ##*[#snd #g]]]
         **[*let [
              [g [x [y z]]]
              ***cadrg
           ]]
      ]]
  "year": |-
    2011
  reference-distribution: Pail distribution


Xoomonk: 
  type: Programming Language
  genre: Esolang
  abstract: "\nXoomonk is a programming language in which _malingering updatable\
    \ stores_\nare first-class objects.  Malingering updatable stores unify several\
    \ language\nconstructs, including procedure activations, named parameters, and\
    \ object-like\ndata structures.\n\nThe Xoomonk project is also a bit of an experiment\
    \ in _test-driven language design_.\nThe specification includes examples in\
    \ the format of [[Falderal]] tests,\nwhich were written while the language was\
    \ being designed and could be used to\ncompare an implementation (when one is\
    \ written) against the spec.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0807
  "ximplementations": !!null |-
    null
  "name": |-
    Xoomonk
  "project": |-
    xoomonk
  sample: |
    l := $loop*
    counter := 5
    l.do := {
      y := x
      print ^.counter
      o := $sub*
      o.x := ^.counter
      o.y := 1
      ^.counter := o.result
      continue := o.result
    }
  "year": |-
    2011
  reference-distribution: Xoomonk distribution


Flobnar: 
  type: Programming Language
  genre: Esolang
  abstract: "\nOne day in September of 2011 \u2014 though I'm not sure precisely\
    \ which\none \u2014 marked [[Befunge-93]]'s 18th birthday.  That means that\
    \ Befunge is\nnow old enough to drink in its native land of Canada.  To celebrate\
    \ this,\nI thought I'd get Befunge-93 drunk to see what would happen.\n\nWhat\
    \ happened was Flobnar, an esolang which is in many respects a\nfunctional dual\
    \ of Befunge-93; most of the symbols have analogous\nmeanings, but execution\
    \ proceeds in a much more dataflow-like fashion.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1028
  "ximplementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Flobnar.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  influences:
  - Befunge-93
  "name": |-
    Flobnar
  "project": |-
    flobnar
  sample: ">     v\n^\\ <   \n       \n:v    v   \\<@\n-<      : 6\n1 :   > *\n\
    \  -|    <\n  11\n"
  "year": |-
    2011
  reference-distribution: Flobnar distribution


Madison: 
  type: Programming Language
  genre: Proof language
  abstract: "\nMadison is a language in which one can state proofs of properties\n\
    of term-rewriting systems.  Classical methods of automated reasoning,\nsuch\
    \ as resolution, are not used; indeed, term-rewriting itself is\nused to check\
    \ the proofs.  Both direct proof and proof by induction\nare supported.  Induction\
    \ in a proof must be across a structure which\nhas a well-founded inductive\
    \ definition.  Such structures can be\nthought of as types, although this is\
    \ largely nominal; the traditional\ntypelessness of term-rewiting systems is\
    \ largely retained.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1202
  "name": |-
    Madison
  "project": |-
    madison
  sample: |
    type tree is
      tree(leaf)        -> true
      tree(branch(X,Y)) -> and(tree(X),tree(Y))
    in let
      reflect(leaf)        -> leaf
      reflect(branch(A,B)) -> branch(reflect(B),reflect(A))
    in theorem
      forall X where tree(X)
        reflect(reflect(X)) ~> X
    proof
      case X = leaf
        reflect(reflect(leaf))
        -> reflect(leaf)        [by reflect.1]
        -> leaf                 [by reflect.1]
      case X = branch(S, T)
        reflect(reflect(branch(S, T)))
        -> reflect(branch(reflect(T),reflect(S)))          [by reflect.2]
        -> branch(reflect(reflect(S)),reflect(reflect(T))) [by reflect.2]
        -> branch(S,reflect(reflect(T)))                   [by IH]
        -> branch(S,T)                                     [by IH]
    qed
  "year": |-
    2011
  reference-distribution: Madison distribution
