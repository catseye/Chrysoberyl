# encoding: UTF-8
beta-Juliet:
  type: Programming Language
  genre: Esolang
  esowiki: beta-Juliet
  summary: A minimal event-oriented programming language
  abstract: |-
    beta-Juliet is a minimal event-based language.  Each event is caused by some other event.
    Event causation is conditional based on which of two given events occurred more recently.
    
    Portia is a preprocessor for beta-Juliet which allows large, regular, finite sets of events
    to be described succinctly.
    
    Version 2.0 of beta-Juliet (formerly known as "2iota") allows infinite sets of events to be
    specified, allowing the language to be Turing-complete.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 2002
  computational-class: believed Turing-complete
  paradigms:
  - Event-oriented
  etymology:
  - automotive pun
  - feminine given name
  reference-distribution: beta-Juliet distribution
  implementations:
  - b_juliet.pl
  - 2iota

b_juliet.pl:
  type: Language Implementation
  in-distribution: beta-Juliet distribution
  license: BSD
  implementation-type: interpreter
  host-language: Perl

2iota:
  type: Language Implementation
  reference: true
  in-distribution: 'beta-Juliet distribution'
  license: BSD
  implementation-type: interpreter
  host-language: C99


Dieter:
  type: Programming Language
  genre: Experimental language
  summary: A language which conflates modules and type qualifiers
  abstract: |-
    Dieter (as in the German masculine given name Dieter, not dieter as in
    "one who diets") is a little experimental programming language that
    conflates *type qualifiers* with *modules* to produce something
    reminiscent of object-orientation.  It demonstrates another way of
    thinking about objects, or rather, classes: not so much as
    *aggregates of data* as *associations of predicates*.
    
    Dieter was intended as a way to make Hungarian notation part of the type
    system, and thus automatically checkable.  However, it also suggests
    possible ways of dealing with the problems of aliasing — that is,
    determining if two pointers cannot possibly point to the same data, for
    safety and optimization considerations.
  paradigms:
  - Object-oriented
  etymology:
  - masculine given name
  sample: |-
    module beefy
      procedure beef_up(x: ♥t): beefy ♥t
      begin
        return (bestow beefy x)
      end
    end.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca Oct 3, 2009
  computational-class: believed Turing-complete
  reference-distribution: Dieter distribution
  implementations:
  - dieter.py

dieter.py:
  type: Language Implementation
  in-distribution: Dieter distribution
  reference: true
  license: BSD
  implementation-type: typechecker
  host-language: Python


Eightebed:
  type: Programming Language
  genre: Esolang
  esowiki: Eightebed
  summary: A safe language with explicit memory deallocation
  abstract: |-
    Eightebed is a small language with explicit `malloc` and `free`.
    Through a modicum of static analysis
    and runtime support, Eightebed is safe: it is not possible to dereference a dangling
    pointer or otherwise incorrectly-populated memory.
    
    Eightebed was designed as a counter-example to Gregor Richards' claim that such
    a language would either need a garbage collector, or not actually implement `free`.
    Eightebed has a real `free` and has no garbage collector.
  commentary: |-
    The name "Eightebed" came from a typo by [[Alise]] for the word "enlightened".
  etymology:
  - typo
  sample: |-
    type node struct {
        int value;
        ptr to node next;
    };
    var ptr to node jim;
    var ptr to node george;
    {    
        jim = malloc node;
        if valid jim {
            [@jim].value = (1 + 4);
            george = jim;
        }
        if valid george {
            print [@george].value;
        }
        free george;
        free jim;
    }
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca Sep 1, 2010
  computational-class: believed Turing-complete
  implementations:
  - 8ebed2c.py

8ebed2c.py:
  type: Language Implementation
  in-distribution: Eightebed distribution
  reference: yes
  license: BSD
  implementation-type: compiler
  source-language: Eightebed
  host-language: Python
  target-language: ANSI C


Full Moon Fever:
  type: Programming Language
  genre: DSL
  summary: A language for describing ANSI terminal animations
  abstract: |-
    Full Moon Fever is a language for describing ASCII animations.
    It was used to deliver animated screens on Chris Pressey's BBS
    (when it was operational in the early 90's) via ANSI terminal control codes.
    This probably counts as his first proper language, even though
    it wasn't a full programming language, because it had
    the usual machinery (syntax, parser, interpreter...)
    Lives on, in a somewhat distended form, as a sub-language of
    [[ILLGOL]].
  commentary: |-
    I believe the name "Full Moon Fever" came from a mis-remembering
    of the title of the song "Full Moon Boogie" by Jan Hammer and
    that other guy.
  etymology:
  - song title
  - error
  sample: |-
    GO 1 2 CLREOL CENTRE "Enter... the Stupid Guard." 2
    GO 1 3 CLREOL
    PAUSE 70
    GO 76 19
    PRINT "0"
    PAUSE 20
    DO 20
        LF PRINT " " LF LF PRINT "0" PAUSE 5;
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1993
  computational-class: known not Turing-complete
  implemented: true


Maentwrog:
  type: Programming Language
  genre: Pedagogical language
  esowiki: Maentwrog
  summary: A simple RPN-calculator-based language
  abstract: |-
    Maentwrog is an RPN-calculator-turned-FORTH-interpreter, which
    probably counts as Chris Pressey's first proper programming language.
    It was implemented on his Amiga 500 in 1993, then lost and unearthed
    multiple times.  It is hardly remarkable, save that it spawned [[Befunge-93]].
  commentary: |-
    There are no extant example programs from the time the language was first
    implemented — I tried writing the Sieve of Eratosthenes in it once,
    but never got it to work, probably because `==` was not
    implemented correctly.  Recently, example programs and a description of the
    language (which has become the provisional spec) have been provided by
    Marinus — thanks Marinus!
    
    Maentwrog is the name of a town in Wales, but the usage of its name
    for this language came via Douglas Adams' "The Meaning of Liff",
    wherein it is defined thusly:
    "MAENTWROG (n. Welsh) Celtic word for a computer spelling mistake."
  etymology:
  - place name
  - welsh
  sample: |-
    GO 1 2 CLREOL CENTRE "Enter... the Stupid Guard." 2
    GO 1 3 CLREOL
    PAUSE 70
    GO 76 19
    PRINT "0"
    PAUSE 20
    DO 20
        LF PRINT " " LF LF PRINT "0" PAUSE 5;
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1993
  computational-class: known not Turing-complete
  implementations:
  - maentw.c
  reference-distribution: Maentwrog distribution

maentw.c:
  type: Language Implementation
  in-distribution: Maentwrog distribution
  license: Freely Redistributable
  reference: yes
  implementation-type: interpreter
  host-language: ANSI C


SMETANA:
  type: Programming Language
  genre: Esolang
  esowiki: SMETANA
  acronym-for: Self-Modifying Extremely Tiny AutomatoN Application
  summary: A pathological little self-modifying language
  abstract: |-
    SMETANA is a pathological little self-modifying language with only two
    possible operations: Go to step *n*, and Swap steps *n* and *m*.
    It has inspired a few variants and developments, notably a proof that
    despite its minimalism, it is finite-automata-complete; it is also the
    (great-?)grandfather of [[SMITH]].
  etymology:
  - dairy product
  - russian
  - surname
  sample: |-
    Step 1. Swap step 1 with step 2.
    Step 2. Go to step 2.
    Step 3. Go to step 1.
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca 1994
  computational-class: known not Turing-complete
  notable: true
  reference-distribution: SMETANA distribution
  implementations:
  - smetana.pl
  - tc.catseye.yoob.smetana
  online-implementations:
  - 'http://catseye.tc/gallery/esolangs/yoob/'

smetana.pl:
  type: Language Implementation
  in-distribution: SMETANA distribution
  license: Public Domain
  reference: yes
  implementation-type: interpreter
  host-language: Perl

tc.catseye.yoob.smetana:
  type: Language Implementation
  in-distribution: yoob distribution
  license: Public Domain
  implementation-type: interpreter
  host-language: Java


SMITH:
  type: Programming Language
  genre: Esolang
  esowiki: SMITH
  acronym-for: Self-Modifying Indecent Turing Hack
  summary: An assembly-like language with no jumps whatsoever
  quotation: How many nights and weird mornings can this go on?
  quotation-attribution: Hunter S. Thompson
  abstract: |-
    SMITH is a self-modifying assembly-like language which completely lacks
    any kind of jump instructions *whatsoever*.  Despite this handicap, it
    appears to be Turing-complete.
  etymology:
  - surname
  sample: |-
    MOV R0, 10
    MOV R2, 0
    SUB R2, 1
    MOV R[R0], "Hello, world!"
    MOV TTY, R[R0]
    SUB R0, R2
    MOV R1, R0
    SUB R1, 23
    NOT R1
    NOT R1
    MUL R1, 8
    COR +1, -7, R1
  authors:
  - Chris Pressey
  auspices:
  - Cat's Eye Technologies
  inception-date: ca July 2000
  computational-class: believed Turing-complete
  notable: true
  significant: true
  reference-distribution: SMITH distribution
  implementations:
  - smith.pl
  influences:
  - SMETANA

smith.pl:
  type: Language Implementation
  in-distribution: SMITH distribution
  reference: yes
  license: BSD
  implementation-type: interpreter
  host-language: Perl


# following languages need some massaging

Befunge-93:
  type: Programming Language
  genre: Esolang
  abstract: |-
    One of the more popular languages I ever designed and implemented.
    Eventually begat [[Befunge-97]], [[Funge-98]], and [[Wierd]], and doubtless influenced
    many others.  Cited in the New Hacker's Dictionary.
  "can-simulate-some-push-down-automata": !!null |-
    null
  "day": |-
    0900
  "etymology":
    "nametag": |-
      typo
  #~ "implementations":
    #~ "implementation":
    #~ - "host-language": |-
        #~ C
      #~ "name": |-
        #~ bef
      #~ "reference": |-
        #~ yes
      #~ "type": |-
        #~ interpreter
    #~ - "host-language": |-
        #~ x86 assembly
      #~ "name": |-
        #~ befia
      #~ "type": |-
        #~ interpreter
  "influences":
    "influence": |-
      Maentwrog
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Befunge-93
  "notable": !!null |-
    null
  "project": |-
    befunge93
  sample: |2
     v    <
    >?"/",^
     >"\",^
  "significant": !!null |-
    null
  quotation: |-
    Hey, my archive must be corrupt.  These sources all look like garbage.
  "tagline-attrib": |-
    Mark Topham
  "year": |-
    1993


Befunge-97:
  type: Programming Language
  genre: Esolang
  abstract: "\nAn unimplemented attempt to improve upon Befunge-93, described\
    \ (fairly accurately) as\n\"brain-damaged.\"  This was primarily due to the\
    \ fact that separate processes were specified\nas sharing a single stack.  Quickly\
    \ gave way to Funge-98.\n  "
  "day": |-
    1225
  "etymology":
    "nametag": |-
      typo
  "failure": !!null |-
    null
  "influences":
    "influence": |-
      Befunge-93
  "name": |-
    Befunge-97
  "year": |-
    1997


RUBE:
  type: Programming Language
  genre: Esolang
  abstract: "\nRUBE is an esoteric programming language in tribute to Rube Goldberg,\
    \ with bulldozers pushing around numbered\ncrates, knocking them together to\
    \ perform computations.  It is based on a variant of\na cellular automaton called\
    \ a *bully automaton*, where certain state changes can\nforce other state changes\
    \ to occur elsewhere in the playfield.\n  "
  "basis-for-game": !!null |-
    null
  "day": |-
    0710
  "etymology":
    "nametag":
    - |-
      masculine given name
    - |-
      acronym
  #~ "implementations":
    #~ "implementation":
      #~ "host-language": |-
        #~ C
      #~ "name": |-
        #~ rube.c
      #~ "reference": |-
        #~ yes
      #~ "type": |-
        #~ interpreter
  "name": |-
    RUBE
  "notable": !!null |-
    null
  "project": |-
    rube
  sample: |2
      0a21646c726f77202c6f6c6c6548
    , :::::::::::::::::::::::::::: ,
     )
     ==============================
    F
                                   O F
                                   c
                                   =
  "year": |-
    1997


Wierd:
  type: Programming Language
  genre: Esolang
  abstract: "\nWierd is a language, inspired somewhat by Befunge-93, where instructions\
    \ are not determined by\nthe symbols in a sequence of symbols, but by the *bends*\
    \ in a sequence of symbols.\n  "
  "believed-turing-complete": !!null |-
    null
  "collaborators": |-
    John Colagioia and Ben Olmstead
  "day": |-
    0101
  "etymology":
    "nametag": |-
      typo
  #~ "implementations":
    #~ "implementation":
    #~ - "author": |-
        #~ John Colagaoia
      #~ "host-language": |-
        #~ C
      #~ "name": |-
        #~ wierd.c
      #~ "type": |-
        #~ interpreter
    #~ - "author": |-
        #~ Milo van Handel
      #~ "host-language": |-
        #~ C
      #~ "name": |-
        #~ wierd-milo.c
      #~ "type": |-
        #~ interpreter
  "influences":
    "influence": |-
      Befunge-93
  "name": |-
    Wierd
  "notable": !!null |-
    null
  "project": |-
    wierd
  sample: |
    *
     *
      *
       *
      * *  **
     *   ** *
      **     **
        *      *
        *     *
        *     *
        *      *
        *     **
        *    *
        * ** *
        **  *
  "sample-credit": |-
    Milo van Handel
  "year": |-
    1997


ALPACA:
  type: Programming Language
  genre: Metalanguage
  abstract: "\nALPACA is a meta-language for describing cellular automata.\nIt\
    \ is an acronym for A Language for Programming\nArbitrary Cellular Automata.\n\
    This is not quite accurate, as the automata are not in fact arbitrary, but it's\
    \ a nice acronym.\n\nALPACA is one of the few of my languages in which I've\
    \ actually implemented\nother languages (or, well, cellular automata \u2014\
    \ close enough).  These\nare, namely, REDGREEN, Braktif, Circute, and Jaccia\
    \ and Jacciata.\n  "
  "day": |-
    0101
  "etymology":
    "nametag": |-
      acronym
  #~ "implementations":
    #~ "implementation":
      #~ "host-language": |-
        #~ Perl
      #~ "name": |-
        #~ alpaca.pl
      #~ "reference": |-
        #~ yes
      #~ "target-language": |-
        #~ Perl
      #~ "type": |-
        #~ compiler
  "meta-language": !!null |-
    null
  "name": |-
    ALPACA
  "notable": !!null |-
    null
  "project": |-
    alpaca
  sample: |
    /* John Conway's Game of Life, expressed in ALPACA. */
    state Dead  " " to Alive when 3 Alive and 5 Dead;
    state Alive "*" to Dead when 4 Alive or 7 Dead.
  "year": |-
    1998


REDGREEN:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: "\nREDGREEN is a cellular automaton that simulates a little\n\"physical\
    \ world\", much like RUBE.\n  "
  "demonstrated-turing-complete": !!null |-
    null
  "etymology":
    "nametag": |-
      television
  #~ "implementations":
    #~ "implementation":
      #~ "host-language": |-
        #~ ALPACA
      #~ "name": |-
        #~ redgreen.alp
      #~ "reference": |-
        #~ yes
      #~ "type": |-
        #~ description
  "influences":
    "influence": |-
      RUBE
  "name": |-
    REDGREEN
  "project": |-
    redgreen
  sample: |2
                                       # #
                     ......            # #
                                       #  ~                      #
                                       #######################   #
                                      %#                         #
                           . . .      T #####                    #
                                      ###   #  :                 #
                                            #                    #
                                            #  .                 #
                                            #                    #
                                            #                    #
                                            #  .                 #
                                            #                    #
                                            #                    #
    >>>>>>>>>>>>>>>##<<<<<<<<<<<<<<<<<############################
                                                    %
                                                    T
  "year": |-
    1998


Circute:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: "\nCircute is a cellular automaton that simulates conduits that\n\
    carry digital signals and NAND gates that manipulate those signals.\n  "
  "etymology":
    "nametag": |-
      portmanteau
  #~ "implementations":
    #~ "implementation":
      #~ "host-language": |-
        #~ ALPACA
      #~ "name": |-
        #~ circute.alp
      #~ "reference": |-
        #~ yes
      #~ "type": |-
        #~ description
  "influences":
    "influence": |-
      Wireworld
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Circute
  "project": |-
    circute
  sample: |2
                      =
                      =
       #######==   ===N===   =========
       #       =   =     =   =       =
     ==N==     = ==N== ==N== =     ==N==
     =   =     = =   = =   = =     =   =
     =====     = ===== ===== =     =====
       =       =   =     =   =       =
       =============     =============
  "year": |-
    2005


Braktif:
  type: Programming Language
  genre: Esolang (Cellular Automaton)
  abstract: "\nBraktif is a cellular automaton modelled closely after the Brainfuck\
    \ programming language.\n  "
  "believed-turing-complete": !!null |-
    null
  "etymology":
    "nametag":
    - |-
      television
    - |-
      portmanteau
    - |-
      french
  #~ "implementations":
    #~ "implementation":
      #~ "host-language": |-
        #~ ALPACA
      #~ "name": |-
        #~ braktif.alp
      #~ "reference": |-
        #~ yes
      #~ "type": |-
        #~ description
  "influences":
    "influence": |-
      Brainfuck
  "name": |-
    Braktif
  "project": |-
    braktif
  sample: |2
                                *
                           <<*[--]*
    000000000000000000  *[-----  --]
    -----------------d-i--         --------
  "year": |-
    2005


Funge-98:
  type: Programming Language
  genre: Esolang
  abstract: "\nCulmination of attempts to improve upon Befunge.  Seemingly everything\
    \ except the\nkitchen sink was stuffed into it somehow.\n  "
  "collaborators": |-
    input from many, many others
  "day": |-
    0101
  "demonstrated-turing-complete": !!null |-
    null
  #~ "implementations":
    #~ "implementation":
    #~ - "host-language": |-
        #~ C
      #~ "name":
        #~ "tool": |-
          #~ no
      #~ "type": |-
        #~ interpreter
    #~ - "author": |-
        #~ Ben Olmstead
      #~ "host-language": |-
        #~ C
      #~ "name":
        #~ "tool": |-
          #~ no
      #~ "type": |-
        #~ interpreter
  "influences":
    "influence":
    - |-
      Befunge-93
    - |-
      Befunge-97
  "name": |-
    Funge-98
  "notable": !!null |-
    null
  "project": |-
    funge98
  sample: |
    >>#v?v
    ^,A' <
     ^ C'
        T
     ^ <<
        G
        '
  quotation: |-
    Taking programming in new directions... all four of them
  "tagline-attrib": |-
    Jason
  "year": |-
    1998


ETHEL:
  type: Programming Language
  genre: DSL
  abstract: "\nA language specifically for expressing quantity surveying\n(materials\
    \ estimating) formula and procedures,\ndesigned for Star Building Materials.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1020
  "etymology":
    "nametag": |-
      acronym
  "implemented": !!null |-
    null
  "inception": |-
    1998
  "name": |-
    ETHEL
  "year": |-
    1998


MDPN:
  type: Programming Language
  genre: Metalanguage
  abstract: "\nMDPN is an acronym for\nMulti-Directional Pattern Notation.\nIt\
    \ is a meta-language for describing\nmulti-directional and multi-dimensional\
    \ languages.\n  "
  "day": |-
    0101
  "etymology":
    "nametag": |-
      acronym
  "meta-language": !!null |-
    null
  "name": |-
    MDPN
  "project": |-
    mdpn
  sample: |2
      Box ::= "+" {"-"}^(w) r(-90) "+" "||" {"|"}^(h) r(-90)
              "+" {"-"}^(w) r(-90) "+" "||" {"|"}^(h) r(-90)
  "year": |-
    1999


#### following languages need heavy massaging ####

raw_dump_of_languages_follow:
  type: dump
  abstract: "\nShelta is an extremely minimal Forth-like language with barely\
    \ any semantics;\nit relies on inline machine code to be considered anywhere\
    \ near Turing-Complete.\nIn the spirit of compilers for languages such as [[FALSE]]\
    \ and [[brainfuck]],\na Shelta-to-8086 compiler was implemented (with help from\
    \ Ben Olmstead) in less than\n512 bytes of 80286 machine code.\nWhat's more,\
    \ it's also been bootstrapped \u2014 that is to say,\na Shelta compiler was\
    \ written in Shelta, which was compiled with the\noriginal compiler, and then\
    \ compiled again with the resulting compiler,\nproducing a wholly self-hosted\
    \ executable!\n  "
  "bootstrapped": !!null |-
    null
  "day": |-
    0601
  "etymology":
    "nametag":
    - |-
      language
    - |-
      celtic
  "implementations":
    "implementation":
    - "host-language": |-
        x86 assembly
      "name": |-
        shelta
      "reference": |-
        yes
      "target-language": |-
        x86 executable
      "type": |-
        compiler
    - "host-language": |-
        Shelta
      "name": |-
        sheltas
      "target-language": |-
        x86 executable
      "type": |-
        compiler
  "name": |-
    Shelta
  "project": |-
    shelta
  sample: |
    [ `Hello, _32 `world! _13 _10 ] \15 outs \0 halt
  "year": |-
    1999
  abstract: "\nSally is a neat little functional language with minimal syntax,\
    \ strict typing, and some\ninteresting parameter rules.\n  "
  "day": |-
    0101
  "etymology":
    "nametag": |-
      feminine given name
  "implementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        sally2c
      "reference": |-
        yes
      "target-language": |-
        C
      "type": |-
        compiler
  "name": |-
    Sally
  "project": |-
    sally
  sample: |
    stdlib
    int factorial int if $1 mul $1 factorial sub $1 1 1
    int main int factorial $1
  quotation: |-
    upside-down FORTH
  "year": |-
    2000
  abstract: "\nBear Food was a horrible language defined by an interpreter that\
    \ evolved\n(no... let's be honest, it *devolved*) from a small\npiece of example\
    \ code showing how to parse and intepret\na simple reverse-polish notation language.\
    \  This same example\ncode also took a very divergent line of evolution, eventually\n\
    becoming the programming language [[Var'aq]].\n  "
  "day": |-
    1201
  "failure": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        bearfood.pl
      "reference": |-
        yes
      "type": |-
        interpreter
      "working": |-
        no
  "name": |-
    Bear Food
  quotation: |-
    liquid insanity from Hell
  "year": |-
    1999
  abstract: "\nTamerlane is a multi-paradigmatic programming language, unimplemented\
    \ and possibly unimplementable.\nOne of its core execution mechanisms is the\
    \ traversing of a graph (representing the program)\nwhile rewriting that same\
    \ graph.\n  "
  "day": |-
    0801
  "etymology":
    "nametag": |-
      masculine given name
  "name": |-
    Tamerlane
  "project": |-
    tamerlane
  sample: |
    Point-A: 1 Point-B,
    Point-B: 1 Point-C,
    Point-C: 1 Point-A.
    ?- 1 Point-A -> 0 Point-A @ Point-A
  "year": |-
    2000
  abstract: "\nSquishy2K is a language which is a hybrid of string rewriting\n\
    and finite state automata; as an added twist, it also lets program\nstates serve\
    \ as functions.  It was based largely on an earlier grammar-based\nlanguage\
    \ called SQUISHY, taking also some ideas from the language [[Thue]].\n\nThe\
    \ original SQUISHY was conceived sometime around 1998, but is now\nlost.  Because\
    \ it was based largely on EBNF, the author wanted to name\nit Wirth, but the\
    \ name SQUISHY was proposed and (somewhat unfortunately)\nstuck.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0901
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        squishy2k.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Squishy2K
  "project": |-
    squishy2k
  sample: |
    * main { start many finish? "Hello, world!"! }
  "year": |-
    2000
  abstract: "\nnoit o' mnain worb is a probabilistic particle automaton\nthat\
    \ uses pressure between randomly moving particles\nto approximate the behaviour\
    \ of circuits.  It can approximate\ncomputation with these circuits, too, but\
    \ it's so lossy that it\nhas more value as just a neat toy to watch.\n\n(The\
    \ name of this language contains a *secret message*!\nCan *you* find it?)\n\
    \  "
  "day": |-
    0915
  "etymology":
    "nametag":
    - |-
      neologism
    - |-
      hidden message
    - |-
      celtic
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        worb.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    noit o' mnain worb
  "notable": !!null |-
    null
  "project": |-
    worb
  sample: |
    #####         #####
    #   ###########   #
    # . >         < . #
    #   #####v#####   #
    #####   #  ########
            #       >!#
            #v#########
            # #
            ###
  quotation: |-
    Under pressure
  "tagline-attrib": |-
    Queen
  "year": |-
    2000
  abstract: "\nHunter is a language I designed for the Esoteric Awards (\"Essies\"\
    ).\nIts abstract starts out like this:\n\n> It is perceived that one of the\
    \ biggest problems in maintaining\n> interest in programming is the above linear\
    \ growth of boredom\n> compared to the usefulness of the program, resulting\
    \ in an\n> acute loss of enthusiasm on the part of the programmers and\n> ultimately\
    \ the abandonment of the software...\n  "
  "day": |-
    0920
  "etymology":
    "nametag": |-
      masculine given name
  "funny": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        hunter.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Hunter
  "project": |-
    hunter
  sample: |
    ##################
    #   1#2#         #
    # #### #         #
    #      #         #
    # ######    M    #
    #     M#         #
    #+######         #
    #     !#         #
    ##################
    *12+>3
    *21+>3
  quotation: |-
    maze-space rewriting with authentic inter-rodent communication
  "year": |-
    2000
  abstract: "\n'N-DCNC was my entry for the 2000 Esoteric Awards ('Essies')\n\
    It is based on a conspiracy theory involving\nUFOs and a 5-member boy band,\
    \ or something.\n  "
  "day": |-
    1001
  "funny": !!null |-
    null
  "implementations":
    "implementation":
    - "host-language": |-
        Perl
      "name": |-
        ndcnc.pl
      "reference": |-
        yes
      "type": |-
        interpreter
    - "host-language": |-
        Befunge-93
      "name": |-
        ndcnc.bf
      "type": |-
        interpreter (broken)
  "name": |-
    'N-DCNC
  "project": |-
    n-dcnc
  sample: |
    4*5+2/2,(9*`c)+1
  "year": |-
    2000
  abstract: "\nStrelnokoff is a non-deterministic imperative\nprogramming language.\
    \  Despite this apparent handicap,\nit appears to be Turing-complete (thanks\
    \ to a short-circuiting multiplication\noperator,) but a critical feature (arrays)\
    \ has never yet been implemented.\n\nThe name \"Strelnokoff\" was taken from\
    \ a fictional brand\nof vodka featured in a mock advertisement on the television\
    \ show\nSCTV.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0401
  "etymology":
    "nametag":
    - |-
      family name
    - |-
      television
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        strelnokoff.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Strelnokoff
  "project": |-
    strelnokoff
  sample: |
    REM HELLO WORLD IN STRELNOKOFF
    REM CHRIS PRESSEY MARCH 24 2001
    X = (X / X) * X + (X = 0) * (T =  0) * (PRINT CHAR 'H' - 'H' +  1)
    X = (X / X) * X + (X = 0) * (T =  1) * (PRINT CHAR 'e' - 'e' +  2)
    X = (X / X) * X + (X = 0) * (T =  2) * (PRINT CHAR 'l' - 'l' +  3)
    X = (X / X) * X + (X = 0) * (T =  3) * (PRINT CHAR 'l' - 'l' +  4)
    X = (X / X) * X + (X = 0) * (T =  4) * (PRINT CHAR 'o' - 'o' +  5)
    X = (X / X) * X + (X = 0) * (T =  5) * (PRINT CHAR ',' - ',' +  6)
    X = (X / X) * X + (X = 0) * (T =  6) * (PRINT CHAR ' ' - ' ' +  7)
    X = (X / X) * X + (X = 0) * (T =  7) * (PRINT CHAR 'w' - 'w' +  8)
    X = (X / X) * X + (X = 0) * (T =  8) * (PRINT CHAR 'o' - 'o' +  9)
    X = (X / X) * X + (X = 0) * (T =  9) * (PRINT CHAR 'r' - 'r' + 10)
    X = (X / X) * X + (X = 0) * (T = 10) * (PRINT CHAR 'l' - 'l' + 11)
    X = (X / X) * X + (X = 0) * (T = 11) * (PRINT CHAR 'd' - 'd' + 12)
    X = (X / X) * X + (X = 0) * (T = 12) * (PRINT CHAR '!' - '!' + 13)
    X = (T = X) * 0 + (X > T) * X REM RESET FLAG
    T = (X / X) * X + (X = 0) * T REM INCREMENT TICK
  "year": |-
    2001
  abstract: "\nJoke languages which parody the sort of language designed by the\
    \ sheer fact\nthat a compiler for it has been hacked together.\n  "
  "day": |-
    0601
  "descendants":
    "descendant":
    - |-
      Illgola-2
    - |-
      Illberon
    - |-
      Illgol##
  "etymology":
    "nametag": |-
      parody
  "funny": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        ILLGOL.COM
      "reference": |-
        yes
      "target-language": |-
        x86 executable
      "type": |-
        compiler
  "inception": |-
    2000
  "name": |-
    ILLGOL
  "project": |-
    illgol
  sample: |
    NB eh.ill
    10 *f = { print str(#0), EoL };
    20 do f(1);
    30 don't f;
    40 do f(2);
    50 reinstate f;
    60 do f(3);
    FIN
  "year": |-
    2001
  abstract: "\nOpus-2 is not a programming language, but rather, an abstract artlang\
    \ (i.e.,\na conlang designed independently from any conception of society.)\n\
    The sole design principle was to entirely eliminate word order.\n  "
  "day": |-
    0701
  "name": |-
    Opus-2
  "project": |-
    opus-2
  sample:
    "mode": |-
      xhtml
    "table":
      "style": |-
        text-align: center;
      "tr":
      - "td":
          "i": |-
            pale green
      - "td":
          "i": |-
            Eb, trombone, forte
      - "td":
          "i": |-
            leaning 40 degrees left (sudden)
      - "td":
          "i": |-
            C, tubular bells, piano
      - "td":
          "i": |-
            mothballs (gentle whiff)
  "significant": !!null |-
    null
  "year": |-
    2001
  abstract: "\nYpsilax is a non-deterministic, reflective, two-dimensional grid-rewriting\n\
    language.  Rewriting rules look for patterns in the grid and\nreplace them with\
    \ other patterns.  These rules are themselves represented by patterns in\nthe\
    \ grid, and therefore rules can match and rewrite other rules.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0801
  "etymology":
    "nametag": |-
      neologism
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        ypsilax.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Ypsilax
  "project": |-
    ypsilax
  sample: |
    (      )  (      )
      #            #
      # ###    ### #
      #            #

        ###   ###

        #      #
        #      #
        #    ###
  "year": |-
    2001
  abstract: "\nVersion is an imperative programming language that uses\n_ignorance-spaces_\
    \ for flow control; the implementation\nignores instructions which matches the\
    \ current ignorance pattern.\n  "
  "day": |-
    0901
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        version.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Version
  "project": |-
    version
  sample: |
    START: ROOM = "VALLEY|BROOK|GLADE"
    CONT: IGNORE = ROOM
    VALLEY: OUTPUT = "You are standing in a valley."
    HILL: OUTPUT = "You are on top of a hill."
    BROOK: OUTPUT = "You are by a brook."
    GLADE: OUTPUT = "You are standing in a sun-dappled glade."
    ROOM: OUTPUT = EOL
    ROOM: DIR = CHOP INPUT
    ROOM: IGNORE = DIR
    ROOM: MASK = "VAPOURS"
    N: CAT = "|N"
    S: CAT = "|S"
    E: CAT = "|E"
    W: CAT = "|W"
    ROOM: IGNORE = MASK
    N: ROOM = "VALLEY|BROOK|GLADE"
    S: ROOM = "HILL|BROOK|GLADE"
    E: ROOM = "VALLEY|HILL|BROOK"
    W: ROOM = "VALLEY|HILL|GLADE"
    LASTLY: IGNORE = "START"
  "year": |-
    2001
  abstract: "\nSbeezg is a syntactically very simple language that attempts to\
    \ take the single-assignment concept\nto a logical extreme.\n  "
  "day": |-
    0101
  "etymology":
    "nametag": |-
      neologism
  "implementations":
    "implementation":
      "host-language": |-
        Erlang
      "name": |-
        sbeezg.erl
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Sbeezg
  "project": |-
    sbeezg
  sample: |
    f={a,b|i=*is;s=*pred;p=*print;g=p(*beer);h=s(a);
       ln={x,m|z=x|x};lg={y,n|q=n(y,n)|y};j=i(h,0,ln,lg);
       k=j(h,b)|a};l=f(99,f)
  "year": |-
    2002
  abstract: "\nGraNoLa/M is a Graph-Node-based Language (possibly for Machines.)\n\
    It was one of my submissions for the Esoteric Awards.\nNot unlike Tamerlane,\
    \ its execution model involves both\ntraversing and rewriting a graph at the\
    \ same time.\n  "
  "day": |-
    0601
  "etymology":
    "nametag": |-
      acronym
  "implementations":
    "implementation":
      "host-language": |-
        Erlang
      "name": |-
        granolam.erl
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      Tamerlane
  "name": |-
    GraNoLa/M
  "project": |-
    granolam
  sample: |
    a=^sajalom(b=^#d(c=^bimodang(^a))d(e=^#cthulhu(f=^uwaming(g=^ubewic()))))
  "year": |-
    2002
  abstract: "\nKangaroo Iceberg was a short-lived attempt to pare down Tamerlane\
    \ to something implementable,\nand implement it.  Although it got a fair ways\
    \ along (e.g. the parser for graphs seems to be complete,)\nI lost interest\
    \ in it at the time, and put off finishing it indefinitely.\n  "
  "day": |-
    0601
  "failure": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        kiceberg
      "reference": |-
        yes
      "type": |-
        interpreter (incomplete)
  "influences":
    "influence": |-
      Tamerlane
  "name": |-
    Kangaroo Iceberg
  "project": |-
    kiceberg
  "year": |-
    2004
  abstract: "\nBeturing is a \"Befunge-flavoured\" language for describing Turing\
    \ machines; both the tape and\nthe finite control are laid out two-dimensionally.\
    \  In addition, the finite control must be\nexpressed as a planar graph (no\
    \ edge representing a transition may cross any other edge.)\nIt was devised\
    \ this way as a test of the so-called \"wire-crossing problem\".\nIt turns out\
    \ that there are universal Turing machines with finite controls that are\nplanar\
    \ graphs, so Beturing is Turing-complete.\n  "
  "day": |-
    1020
  "demonstrated-turing-complete": !!null |-
    null
  "etymology":
    "nametag": |-
      portmanteau
  "implementations":
    "implementation":
      "host-language": |-
        Lua
      "name": |-
        beturing.lua
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Beturing
  "project": |-
    beturing
  sample: |
    # D(40, 4)
    # @(40, 4)
    $bbab$
    # C(0, 0)
    # @(0, 0)
     . . . . . .
    *v*<*<*<*>*v
    aa .ab . .aa .
    >/*>./*^*^</*v
    bb .ba . .bb .
    >/*^./*^*^</*v
    $$ .$$ . .$$ .
    >/*^</*>*^.@*v
             . . .
    *@      *^*<*<
  "year": |-
    2005
  abstract: "\nBhuna is a small, garbage-collected language with a simple\nsyntax,\
    \ closures, inferred types, lightweight processes, and support for UTF-8\nsource\
    \ code.  It was implemented partly to see how closely I could match\nthe performance\
    \ of Lua's interpreter.  It was meant more more as an experimental\nstarting\
    \ point for branching new languages, than as a useful language in and of itself.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1021
  "etymology":
    "nametag":
    - |-
      indian
    - |-
      dish
  "implementations":
    "implementation":
      "host-language": |-
        C
      "name": |-
        bhuna
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      Lua
  "name": |-
    Bhuna
  "project": |-
    bhuna
  sample: |
    Fib = ^ X {
      if X < 2 return 1 else
      return Fib(X - 1) + Fib(X - 2)
    }
    Print Fib(32), EoL
  "year": |-
    2005
  abstract: "\nXigxag is a simple string-copying automaton that has exponential\
    \ growth almost everywhere\n(i.e. there are only a finite number of initial\
    \ configurations that don't blow up.)\n  "
  "day": |-
    0423
  "implementations":
    "implementation":
      "host-language": |-
        Perl
      "name": |-
        xigxag.pl
      "reference": |-
        yes
      "type": |-
        interpreter
  "inception": |-
    2001
  "name": |-
    Xigxag
  "project": |-
    xigxag
  sample:
    "mode": |-
      output
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2007
  abstract: "\nHev is a programming language that attempts to solve the \"central\
    \ problem of\ninfix notation\": how do you allow it without requiring the programmer\
    \ to either\nmemorize precedence tables or litter parentheses everywhere?  Hev\
    \ has a way!\nIn Hev, *all* operators are infix, yet no tiresome memorization\
    \ of any\ndreadful precedence table is required!\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0523
  "etymology":
    "nametag": |-
      neologism
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Hev.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Hev
  "project": |-
    hev
  sample: |
    71+8*27,19,29*99,6,37,7,61,47
  "year": |-
    2007
  abstract: "\nBurro is a [[brainfuck]]-like programming language whose programs\n\
    form an algebraical _group_ (modulo the equivalence relation of \"computes the\
    \ same function\")\nunder the operation of concatenation.\nThe upshot of this\
    \ is that, for every Burro program, we can find\nan _antiprogram_ which, when\
    \ appended to the program,\nforms a \"no-op\" program which has no effect.\n\
    \nThis is a form of reversible computing, but unlike most reversible languages\n\
    where it is the execution of the program that is \"undone\", in Burro, it is\
    \ the\nprogram itself which is annihiliated by its antiprogram.\n\nBurro 1.0\
    \ was released in fall of 2007, but proved not to form a proper group.\nThis\
    \ shortcoming was rectified in summer of 2010.\n  "
  "day": |-
    0607
  "demonstrated-turing-complete": !!null |-
    null
  "etymology":
    "nametag": |-
      spanish
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Burro.lhs
      "reference": |-
        yes
      "type": |-
        interpreter
  "inception": |-
    2005
  "influences":
    "influence": |-
      Brainfuck
  "name": |-
    Burro
  "project": |-
    burro
  sample: |
    !--(--(--(!>/
      >>--(+<<+++++++>/+++>+++++>)<
    >)/
      >>--(+++>+++++>/+++<<<<<+++>)<
    >)/
      >>--(+++>+>/+<<+++>)<
    >)<
  "significant": !!null |-
    null
  "year": |-
    2010
  abstract: "\nCabra is a (somewhat) formal programming language whose programs\
    \ form an algebraical\n_dioid_ (an idempotent semiring), modulo the equivalence\
    \ relation of \"computes the same function\",\nunder the operations of parallel\
    \ execution (as the additive operator) and sequential composition\n(as the multiplicative\
    \ operator).\n  "
  "day": |-
    1030
  "etymology":
    "nametag": |-
      spanish
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        cabra.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      Burro
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Cabra
  "project": |-
    cabra
  sample: |
    (SET 1 + SET 2) * IFSET 1 THEN (IFSET 2 THEN SET 3 ELSE SKIP) ELSE SKIP
  "year": |-
    2007
  abstract: "\nYou are Reading the Name of this Esolang is an exploration in\n\
    the design space of programming languages with undecidable elements.\nIts syntax\
    \ is only recursively enumerable:\nthe problem of determining whether or not\n\
    a given string of symbols is a well-formed\nYou are Reading the Name of this\
    \ Esolang program is undecidable.\n  "
  "day": |-
    1101
  "demonstrated-turing-complete": !!null |-
    null
  "influences":
    "influence": |-
      Spoon
  "name": |-
    You are Reading the Name of this Esolang
  "project": |-
    urreading
  sample: |
    001000000[0010000000111001000011]11100100001[0]
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2007
  abstract: "\nEmmental is a self-modifying programming language.  It is defined\
    \ in terms\nof a meta-circular interpreter, and this meta-circular interpreter\
    \ provides\nan operation that redefines operations of the meta-circular interpreter.\
    \  In\nfact, this mechanism is required for Emmental to be Turing-complete.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1111
  "etymology":
    "nametag":
    - |-
      dairy
    - |-
      swiss
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        emmental.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Emmental
  "project": |-
    emmental
  sample: |
    ;#58#126#63#36!;#46#36#!;#0#1!;#0#2!;#0#3!;#0#4!;#0#5!;#0#6!;#0#7!#0#33#111#108#108#101#72$
  "year": |-
    2007
  abstract: "\nDidigm is a reflective cellular automaton: the transition rules\
    \ for the\nautomaton are defined by forms in the very playfield governed by\
    \ those transition rules.\n  "
  "day": |-
    1120
  "etymology":
    "nametag": |-
      neologism
  "name": |-
    Didigm
  "project": |-
    didigm
  sample: |
    3333333333333
    3002300230073
    3111311132113
    3311321131573
    3111311131333
    3333333333333
    =F3
    ,
    =F1
    111111111111111
    111111131111111
    111111111111574
    111111111111333
    311111111111023
    111111111111113
  quotation: |-
    Didigm = ALPACA + Ypsilax
  "year": |-
    2007
  abstract: "\nIphigeneia is a toy programming language which contains features\
    \ from both\nimperative programming (assignments to mutable variables, `while`\
    \ loops,)\nand functional programming (immutable name bindings,\nScheme-style\
    \ \"named `let`\" loops.)\nIt was originally intended as a testbed for\nalgorithms\
    \ that convert programs between the two forms.\n  "
  "day": |-
    1120
  "etymology":
    "nametag":
    - |-
      classical greek
    - |-
      mythological
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        iphi
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Iphigeneia
  "project": |-
    iphi
  sample: "var a in a :=\n    let c = 5 in let d = 1 in\n        loop\n\t    if\
    \ c = 0 then\n\t        d\n\t    else\n\t        let d = d * c in\n\t      \
    \      let c = c - 1 in\n\t\t        repeat\n"
  "year": |-
    2007
  abstract: "\nMascarpone is a self-modifying language able to\nalter the meta-circular\
    \ interpreter which defines it, like its predecessor\nEmmental.  Unlike Emmental\
    \ however, in Mascarpone\ninterpreters are first-class objects,\nmaking the\
    \ job of reflective interpreter-modification quite a bit cleaner and\nricher.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1210
  "etymology":
    "nametag":
    - |-
      dairy
    - |-
      italian
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        mascarpone.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      Emmental
  "name": |-
    Mascarpone
  "project": |-
    mascarpone
  sample: |
    v['[/''/']v*]v*'?<^v[/?/<]v*'S<[>!]v*'F<^[]v*1'p'kS'kF.
  "significant": !!null |-
    null
  quotation: |-
    You are lost in a twisty little maze of meta-circular intepreters, all alike
  "year": |-
    2007
  abstract: "\nLarabee is an assembly-like programming language, with Scheme-like\
    \ syntax,\nthat borrows the notion of branch prediction from computer architecture\n\
    and abuses it, creating a path that leads only to existential angst and self-destruction.\n\
    \  "
  "day": |-
    0110
  "etymology":
    "nametag": |-
      television
  "implementations":
    "implementation":
      "host-language": |-
        Scheme
      "name": |-
        larabee.scm
      "reference": |-
        yes
      "type": |-
        interpreter
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Larabee
  "project": |-
    larabee
  sample: |-
    (store (input) (input)
      (store (input) (input)
        (label loop
          (store (input) (op * (fetch (input)) (fetch (input)))
            (store (input) (op - (fetch (input)) (input))
              (test (op > (fetch (input)) (input))
                (goto loop) (print (fetch (input)))))))))
  "year": |-
    2008
  abstract: "\nArboretuum is an experimental language based on _forest-rewriting_,\n\
    a variant of tree-rewriting in which multiple trees are rewritten simultaneously.\n\
    The language was intended for specifying compilers, with each tree representing\n\
    a major compiler data structure (AST, symbol table, output buffer, etc.,)\n\
    however, this idea was not entirely successful.  Regardless, Arboretuum is\n\
    Turing-complete, as tree-rewriting is simply a special case of forest-rewriting.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0301
  "etymology":
    "nametag":
    - |-
      latin
    - |-
      portmanteau
  "implementations":
    "implementation":
      "host-language": |-
        Scheme
      "name": |-
        forest-rewriter.scm
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Arboretuum
  "project": |-
    arboretuum
  sample: |-
    (
      (
        (ast:   (let a 4 (+ 3 (* a 3))) )
        (stab:  eot)
        (out:   halt)
      )
      (
        ((ast:  (let #(n sym) #(v) #(expr)) => #(expr)            )
         (stab: eot                         => (#(n) #(v) EOT)    ))
        ((ast:  #(n sym)                    => #(v)               )
         (stab: (#(n) #(v) #(tab))          => (#(n) #(v) #(tab)) ))
        ((ast: #(a num)                     => _                  )
         (out: halt                         => (push #(a) halt)   ))
        ((ast: (+ _ _)                      => _                  )
         (out: halt                         => (add halt)         ))
        ((ast: (* _ _)                      => _                  )
         (out: halt                         => (mul halt)         ))
      )
    )
  "year": |-
    2008
  abstract: "\nTreacle is an experimental compiler-definition language based on\n\
    _context rewriting_, an expressive variant of term rewriting\nthat generalizes\
    \ the forest-rewriting used by its predecessor [[Arboretuum]].\nIn context rewriting,\
    \ a separation is made between _names_ and _variables_,\nand patterns may contain\
    \ _holes_\ninside which subpatterns may match at any depth.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0412
  "etymology":
    "nametag":
    - |-
      british
    - |-
      condiment
  "implementations":
    "implementation":
      "host-language": |-
        Scheme
      "name": |-
        treacle.scm
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      Arboretuum
  "name": |-
    Treacle
  "project": |-
    treacle
  sample:
    "mode": |-
      output
  "year": |-
    2008
  abstract: "\nQuylthulg is a programming language with but a single \ncontrol-flow\
    \ construct: `foreach`.  In fact, it \ndoes also have a `goto`, but that can\
    \ only appear \ninside data structures.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1206
  "etymology":
    "nametag": |-
      mythological
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name":
        "tool": |-
          no
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Quylthulg
  "project": |-
    quylthulg
  sample: |-
    foreach $n$=:L:[1,2,3|goto$L$] with $a$=1 be +$a$+$n$+ else be abort
  "year": |-
    2008
  abstract: "\nUnlikely is a programming language that conflates objects with\
    \ continuations,\nand methods with labels.  It exposes program structures as\
    \ objects with\ncommensurate inheritance relationships.  It also takes dependency\
    \ injection to\nthe logical extreme: if some class is used by an object, that\
    \ class *must* be\nspecified when the object is instantiated.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0315
  "implementations":
    "implementation":
      "host-language": |-
        Python
      "name":
        "tool": |-
          no
      "type": |-
        static analyzer
  "name": |-
    Unlikely
  "project": |-
    unlikely
  sample: |-
    class Count(Count,Chain,Print,Add) extends Continuation

    class CountForever(Count,Chain,Print,Add) extends Program {
      Count c;
      method continue(Passive accumulator) {
        c = new Count(Passive,Count,Chain,Print,Add);
        goto c.continue(new 1(Passive));
      }
    }

    class Count() extends Continuation {
      Count c;
      Print p;
      Add a;
      method continue(Passive accumulator) {
        c = new Count(Passive,Count,Chain,Print,Add);
        a = new Add(Passive,Chain);
        a.value = new 1(Passive);
        a.next = c;
        p = new Print(Passive,Chain);
        p.next = a;
        goto p.continue(accumulator);
      }
    }
  "year": |-
    2009
  abstract: "\nJaccia and Jacciata are cellular automata inspired by the\n[Announcement\
    \ of Scientific Proof that Slime Molds are\nIntelligent Maze Solvers](http://web.archive.org/web/20020220163303/http://www.riken.go.jp/lab-www/frontier-div/NEWSLETTER/feb2001/ameboid_e.htm).\n\
    Jaccia can solve mazes too, by a similar mechanism (shrinking).\nJacciata builds\
    \ upon this to find the shortest path through a maze, if one exists and is unique.\n\
    \  "
  "day": |-
    0411
  "etymology":
    "nametag": |-
      neologism
  "implementations":
    "implementation":
    - "host-language": |-
        ALPACA
      "name": |-
        jaccia.alp
      "reference": |-
        yes
      "type": |-
        description
    - "host-language": |-
        ALPACA
      "name": |-
        jacciata.alp
      "reference": |-
        yes
      "type": |-
        description
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Jaccia and Jacciata
  "project": |-
    jaccia
  sample:
    "mode": |-
      output
  "year": |-
    2009
  abstract: "\nPixley is a strict subset of R5RS Scheme (or, if you prefer, R4RS\
    \ Scheme),\nsupporting four datatypes (boolean, cons cell, function, and symbol)\
    \ and\na dozen built-in symbols.  The reference implementation of Pixley\nis\
    \ written in 124 lines of Pixley (or, if you prefer, 124 lines of Scheme;\n\
    and if you prefer more Scheme-ly metrics, it consists of 413 instances of\n\
    54 unique symbols in 684 cons cells.)\n  "
  "believed-turing-complete": !!null |-
    null
  "bootstrapped": !!null |-
    null
  "day": |-
    0501
  "etymology":
    "nametag":
    - |-
      placename
    - |-
      television
  "implementations":
    "implementation":
      "host-language": |-
        Pixley
      "name":
        "tool": |-
          yes
      "reference": |-
        yes
      "type": |-
        interpreter
  "name": |-
    Pixley
  "project": |-
    pixley
  sample: |-
    (let* ((a (lambda (x y) (cons x y)))) (a (quote foo) (quote ())))
  "year": |-
    2009
  abstract: "\nEtcha is a two-dimensional descendant of Jeffry Johnston's\n[BitChanger].\
    \  Like BitChanger, it has four instructions;\nunlike BitChanger, its storage\
    \ model is based on turtle graphics, which permits it to be immediately used\
    \ for an\nalternative purpose: graphical composition. Unlike the turtle in LOGO\
    \ however, the turtle in Etcha is an integral part of the\ncomputation, playing\
    \ a role similar to the tape head of a Turing machine.\n  "
  "day": |-
    1004
  "demonstrated-turing-complete": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        Java
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      BitChanger
  "name": |-
    Etcha
  "project": |-
    etcha
  sample:
    "mode": |-
      output
  "year": |-
    2009
  abstract: "\nZOWIE is a machine-like language in which all operations *including\
    \ structured control flow* are memory-mapped.\nControl flow is structured in\
    \ the sense of structured programming \u2014\nthe programmer never deals with\
    \ `goto`s, or offsets or labels of any kind.\nInstead, the program writes to\
    \ a memory location to mark the beginning or end of a loop or conditional.\n\
    \  "
  "day": |-
    1229
  "demonstrated-turing-complete": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        Python
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "influences":
    "influence": |-
      BitChanger
  "name": |-
    ZOWIE
  "project": |-
    zowie
  sample: |
    MOV R10, 90
    MOV R1, R1
    MOV R0, R10
    MOV R8, R10
    MOV R5, 1
    MOV R10, R8
    MOV R8, R10
    MOV R5, 64
    MOV R3, R8
  "year": |-
    2009
  abstract: "\nOkapi is a language I designed as an anniversary present for my\
    \ wife(!).\nIn it, the only means of control flow is throwing exceptions, and\
    \ as if this wasn't\nenough, there are two restrictions on exceptions that are\
    \ thrown \u2014 they\nmust be divide-by-zero exceptions, and they must be caught\
    \ in a lexically\nenclosing block.  Nor is there any facility to \"retry\" after\
    \ an exception is caught.\nThe language is nonetheless Turing-complete.\n  "
  "day": |-
    0523
  "demonstrated-turing-complete": !!null |-
    null
  "implementations":
    "implementation":
      "host-language": |-
        Python
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "influences": !!null |-
    null
  "name": |-
    Okapi
  "year": |-
    2010
  abstract: "\nWhothm is a simple language for describing infinite\ntwo-colour\
    \ bitmapped drawings.\n  "
  "day": |-
    0628
  "implementations":
    "implementation":
      "host-language": |-
        Java
      "name":
        "tool": |-
          yes
      "type": |-
        interpreter
  "influences": !!null |-
    null
  "known-not-turing-complete": !!null |-
    null
  "name": |-
    Whothm
  "project": |-
    whothm
  sample: |
    r := (0, 0, 1, 2);
    s := (0, 0, 1, 2);
    XOR := TF/FT;

    begin
    r.x += r.w;
    r.x += -1;
    r.w += 1;
    r.h += 1;
    draw r, XOR;
    s.x += s.w;
    s.x += -1;
    s.w += 1;
    s.h += 2;
    draw s, XOR;
    end
  "year": |-
    2010
  abstract: "\nThe name of this language is Oozlybub and Murphy.\nDespite appearances,\
    \ this name refers to a single language.\nThe majority of the language is named\
    \ Oozlybub.\nThe fact that the language is not entirely named Oozlybub is named\
    \ Murphy.\nDeal with it.\n\nFor the sake of providing an \"olde tyme esoterickal\
    \ de-sign\",\nthe language combines several unusual features, including multiple\
    \ interleaved\nparse streams, infinitely long variable names, gratuitously strong\
    \ typing, and\nonly-conjectural Turing completeness.\n  "
  "day": |-
    1201
  "implementations": !!null |-
    null
  "influences": !!null |-
    null
  "name": |-
    Oozlybub and Murphy
  "project": |-
    oozlybub-and-murphy
  sample: |
    VARIABLES ARE p /p*/, p /q*/.
    dynast(3) <->
      (. do (. if? not? exists/dynast 5 ,then
           create/countably/many/dynasts #myself#, 5 .) .) ,then
      (. for each prime /p*|p/ below #myself#+2 do
           for each prime /q*|q/ below /p*|pp/+1 do
             if? not? exists/dynast /p*|p|p/+/q*|q|q/ ,then
               copy/dynast #myself#, /p*|ppp/, /q*|qqq/ .)
  "unusual-computability-properties": !!null |-
    null
  "year": |-
    2010
  abstract: "\nGemooy is really just a two-dimensional bagatelle of sorts; it\
    \ combines features from\n[[2-ill]] and [[Etcha]], and adds self-modification.\
    \ It came about when I noticed\nthe tape-related semantics of 2-ill were essentially\
    \ the same as those of\n[[BitChanger]].\n\n(Information on this language is\
    \ only available on the esowiki for now.)\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1202
  "implementations": !!null |-
    null
  "implemented": !!null |-
    null
  "influences":
    "influence":
    - |-
      2-ill
    - |-
      Etcha
  "name": |-
    Gemooy
  sample: "%### # ###   # #   ### # ###   # #   ### # ###@\n\n   @    @#     \
    \    @\n  @      @          @\n @@\n@                   @\n    $         @#\
    \ # @\n             #      @\n            #\n       @   @\n                \
    \    @\n         \n       @\n      #\n     #\n    @\n    @    @\n     @# @\n\
    @        @\n         @\n  @     @#@\n"
  "year": |-
    2010
  abstract: "\nNhohnhehr is a remotely fungeoid language which explores the design\
    \ space between having\na fixed playfield versus an expandable one.  When the\
    \ instruction pointer reaches the edge of\nthe playfield (the \"room\"), whether\
    \ it wraps around or creates a new room and adjoins it to that\nedge, depends\
    \ on the current _edge mode_ of the program.  New copies of rooms may\nbe rotated\
    \ before being adjoined to existing rooms, but rooms are otherwise immutable.\n\
    \  "
  "can-simulate-some-push-down-automata": !!null |-
    null
  "day": |-
    1208
  "implementations":
    "implementation":
      "host-language": |-
        Python
      "name": |-
        nhohnhehr.py
      "type": |-
        interpreter
  "implemented": !!null |-
    null
  "influences":
    "influence":
    - |-
      2-ill
    - |-
      Etcha
  "name": |-
    Nhohnhehr
  "project": |-
    nhohnhehr
  sample: |
    +------+
    |    /}|
    |&#/$?@|
    |  / \&|
    |      |
    | {    |
    |\\    |
    +------+
  "year": |-
    2010
  abstract: "\nKelxquoia is another remotely fungeoid language, this one self-modifying\
    \ \u2014 in fact,\nself-destroying.  As instructions are executed, they are\
    \ erased.  In order to execute\nindefinitely, new instructions of some sort\
    \ must be created.\nLuckily the language provides as its main data-manipulation\
    \ facility, grid-rewriting,\nwhich can be used to restore instructions that\
    \ were previously erased after execution.\n\n(Information on this language is\
    \ only available on the esowiki for now.)\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1223
  "implementations": !!null |-
    null
  "influences": !!null |-
    null
  "name": |-
    Kelxquoia
  sample: " >+-0 0*+-1*/+-?*-R*- *+-?*-R*-?*/v\n RRRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRR\n\
    $>+-0 0*+-1*/+-?*-R*- *+-?*-R*-?*/v\n    ' '   '       '  '      '   \n    \
    \         '         '  '     \n ^      /*?-*P-*?-+*?-*P-* -+     <\n P     \
    \ PPPPPPPPPPPPPPPPPP PP     P\n ^      /*?-*P-*?-+*?-*P-* -+     <\n\n 00 00\
    \ 00 00\n"
  "year": |-
    2010
  abstract: "\nWunnel is a two-dimensional language which draws from the\n[[1L]]\
    \ family of languages and incorporates features from [[reMorse]].\nThe name\
    \ is both a play on the pronunciation of \"1L\", and\na recursive portmanteau\
    \ of the words _Wunnel_ and _tunnel_\nwhich is used to describe the long sequences\
    \ of identical instructions (often nops) used in\nWunnel programs to sync up\
    \ remote parts of the program.\n\n(Information on this language is only available\
    \ on the esowiki for now.)\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0213
  "implementations":
    "implementation":
      "host-language": |-
        Java
      "name": |-
        WunnelState.java
      "type": |-
        interpreter
  "implemented": !!null |-
    null
  "influences": !!null |-
    null
  "name": |-
    Wunnel
  sample: |2
              o   ooo  o


    o
    o
    o
    o         o
    o         o
    o         o
    o         o
    o
    o        o     o
    o         o
    o
    o        o
    o              o
    o        o     o
    o              o

             o
    o oooooooo     o
             o
             o
             o

             o    oooo o
  "year": |-
    2011
  abstract: "\nPail is a programming language based on pairs; just as Lisp stands\
    \ for\nLISt Processing, Pail stands for PAIr Language.\nIts original working\
    \ title was \"Bizaaro[sic]-Pixley\", as it attempts to resemble\n[[Pixley]]\
    \ while turning several concepts on their heads: use pairs instead of lists,\n\
    quote by default instead of eval by default, and allow not just values but also\n\
    names of bindings to be expressed.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0525
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Pail.lhs
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences": !!null |-
    null
  "name": |-
    Pail
  "project": |-
    pail
  sample: |
    **[*let [
         [cadrg *[#fst ##*[#snd #g]]]
         **[*let [
              [g [x [y z]]]
              ***cadrg
           ]]
      ]]
  "year": |-
    2011
  abstract: "\nXoomonk is a programming language in which _malingering updatable\
    \ stores_\nare first-class objects.  Malingering updatable stores unify several\
    \ language\nconstructs, including procedure activations, named parameters, and\
    \ object-like\ndata structures.\n\nThe Xoomonk project is also a bit of an experiment\
    \ in _test-driven language design_.\nThe specification includes examples in\
    \ the format of [[Falderal]] tests,\nwhich were written while the language was\
    \ being designed and could be used to\ncompare an implementation (when one is\
    \ written) against the spec.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0807
  "implementations": !!null |-
    null
  "influences": !!null |-
    null
  "name": |-
    Xoomonk
  "project": |-
    xoomonk
  sample: |
    l := $loop*
    counter := 5
    l.do := {
      y := x
      print ^.counter
      o := $sub*
      o.x := ^.counter
      o.y := 1
      ^.counter := o.result
      continue := o.result
    }
  "year": |-
    2011
  abstract: "\nOne day in September of 2011 \u2014 though I'm not sure precisely\
    \ which\none \u2014 marked [[Befunge-93]]'s 18th birthday.  That means that\
    \ Befunge is\nnow old enough to drink in its native land of Canada.  To celebrate\
    \ this,\nI thought I'd get Befunge-93 drunk to see what would happen.\n\nWhat\
    \ happened was Flobnar, an esolang which is in many respects a\nfunctional dual\
    \ of Befunge-93; most of the symbols have analogous\nmeanings, but execution\
    \ proceeds in a much more dataflow-like fashion.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1028
  "implementations":
    "implementation":
      "host-language": |-
        Haskell
      "name": |-
        Flobnar.hs
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences": !!null |-
    null
  "name": |-
    Flobnar
  "project": |-
    flobnar
  sample: ">     v\n^\\ <   \n       \n:v    v   \\<@\n-<      : 6\n1 :   > *\n\
    \  -|    <\n  11\n"
  "year": |-
    2011
  abstract: "\nMadison is a language in which one can state proofs of properties\n\
    of term-rewriting systems.  Classical methods of automated reasoning,\nsuch\
    \ as resolution, are not used; indeed, term-rewriting itself is\nused to check\
    \ the proofs.  Both direct proof and proof by induction\nare supported.  Induction\
    \ in a proof must be across a structure which\nhas a well-founded inductive\
    \ definition.  Such structures can be\nthought of as types, although this is\
    \ largely nominal; the traditional\ntypelessness of term-rewiting systems is\
    \ largely retained.\n  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    1202
  "implementations": !!null |-
    null
  "influences": !!null |-
    null
  "name": |-
    Madison
  "project": |-
    madison
  sample: |
    type tree is
      tree(leaf)        -> true
      tree(branch(X,Y)) -> and(tree(X),tree(Y))
    in let
      reflect(leaf)        -> leaf
      reflect(branch(A,B)) -> branch(reflect(B),reflect(A))
    in theorem
      forall X where tree(X)
        reflect(reflect(X)) ~> X
    proof
      case X = leaf
        reflect(reflect(leaf))
        -> reflect(leaf)        [by reflect.1]
        -> leaf                 [by reflect.1]
      case X = branch(S, T)
        reflect(reflect(branch(S, T)))
        -> reflect(branch(reflect(T),reflect(S)))          [by reflect.2]
        -> branch(reflect(reflect(S)),reflect(reflect(T))) [by reflect.2]
        -> branch(S,reflect(reflect(T)))                   [by IH]
        -> branch(S,T)                                     [by IH]
    qed
  "year": |-
    2011
  abstract: "\nVelo is a vaguely Ruby-inspired \"scripting\" language which unifies\
    \ strings\nwith code blocks, and scripts with object classes.  Curly braces\
    \ delimit string\nliterals, and there is no difference between a string literal\
    \ and a block of code\ngiven to, say, an `if` statement.  Any given script is\
    \ an object,\nwhich inherits from the root object in delegation-OO style.\n\
    \  "
  "believed-turing-complete": !!null |-
    null
  "day": |-
    0714
  "implementations":
    "implementation":
      "host-language": |-
        Ruby
      "name": |-
        velo.rb
      "reference": |-
        yes
      "type": |-
        interpreter
  "influences": !!null |-
    null
  "name": |-
    Velo
  "project": |-
    velo
  sample: "yes = {IO.print {Yes}}\nno = {IO.print {No}} \nif ({X}.equals {Y}),\
    \ yes, no \n"
  "year": |-
    2012

