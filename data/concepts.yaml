# encoding: UTF-8
# this one's a real grab-bag, for now

Chrysoberyl:
  type: Concept
  description: |
    _Chrysoberyl_ is an attempt to catalogue and curate 
    all things produced by, and related to, [[Cat's Eye Technologies]].
    It is sort of a cross between a wiki and a semantic web and
    _[[The Devil's Dictionary]]_.  The grammar and diction of its auto-generated
    descriptions might not be so hot at times; please cut it some slack in this regard.


# thass right, catseye.tc is just a concept now.  and what a concept!
catseye.tc:
  type: Concept
  description: |
    `catseye.tc` is [[Cat's Eye Technologies]]' website:
    [http://catseye.tc/](http://catseye.tc/).
    
    It was, until recently, the official distribution channel of Cat's Eye
    Technologies' public offerings — mostly software distributions, but also some
    electronics projects, unsolicited opinions, and other miscellany.  And in fact, it
    will continue to be canonical, in many respects; but many software
    services, such as public and distributed version-control repositories,
    and issue tracking, are now handled offsite, at Cat's Eye Technologies'
    accounts on 
    [Github](https://github.com/catseye/) and
    [Bitbucket](https://bitbucket.org/catseye/).
    
    In years past, the Cat's Eye Technologies web site was hosted on
    various different domains.  From most recently to least recently, they
    were:
    
    *   `catseye.tc`
    *   `catseye.webhop.net`
    *   `catseye.mine.nu:8080`
    *   `www.catseye.mb.ca`
    *   `www.cats-eye.com`
    *   and way back in the mists of time, `www.pangea.ca/cet/`.
    
    This frequent relocation of our web address was done specifically to
    please [[Phantom Hoover]].
        
    `catseye.tc` has turned out to be more-or-less permanent.  Feel free to
    make links to this site using URLs that begin with
    `http://catseye.tc/`. The `www` prefix is not required.
        
    Our aim in making this website is that it both conforms to W3C
    standards and provides a reasonable user experience. Given the
    sheer variation that exists between browsers, this is not always easy.
        
    We use [[CSS]] for layout of these pages; we no longer use tables, or
    anything resembling tables (like `display: table-cell`), for layout.
    
    We do use [[Javascript]] on the pages on this site, but we try to do
    so judiciously.
    
    Our webpages strive to
    conform to the W3C Recommendation [XHTML 1.0
    Strict](http://www.w3.org/TR/xhtml1/).
    Most of the webpages on this site are generated from underlying XML
    documents using XSLT stylesheets, even the pages which do not have any
    significant data structure to them. This is not just for buzzword
    conformance — it helps in catching XHTML errors early, as well as
    providing formatting and layout that is consistent across the site while
    being easy to change.
    
    However, everything in the above paragraph is likely going to change
    in the near future.  Our working plan is to generate the website as
    HTML 5 from a loosely-structured database of things we've done and
    seen, stored in YAML files, called [[Chrysoberyl]].  Stay tuned.


Galois connection:
  type: Concept
  description: |
    A Galois connection is a pair of complementary maps with certain
    properties between a pair of complementary sets.
    
    Galois connections provide a mathematical basis for abstract
    interpretation, and they are possibly easiest to understand from
    examples given in that context.
    
    We can think of our pair of sets as being a set of *concrete* values
    (such as {0, 1, 2, ... }) and a set of *abstract* values (such as
    {`int`, `even`, `odd`, `power-of-two`, `prime`, ... }).
    
    We then think of our pair of maps as being an *abstractifying* map which
    takes elements of the concrete value set and sends them to elements of
    the abstract value set, and a *concretizing* map which takes elements of
    the abstract value set and sends them to elements of the concrete value
    set.
    
    This pair of maps is a Galois connection when, if some abstract value
    (such as `even`) maps to some set of concrete values (such as {2, 4, 6,
    8, ... }), then any concrete value in that set (such as 8) also maps to
    some (possibly specialized) instance of the abstract value (such as
    `power-of-two`).
    
    That's not quite the whole story, but it seems like the most intuitive
    version to me.
    
    Now there's nothing saying that the sets have to be "abstract" or
    "concrete" or that the maps have to be "abstractifying" or
    "concretizing" -- those are just from this one application in abstract
    interpretation. On the other hand, the structure inherent in the Galois
    connection does lend itself to relationships like this.


Open-source:
  type: Concept
  commentary: |
    We believe that open-source software has an important civic and didactic
    role in modern society. Civic, in that with it, communities of
    individuals with common software needs can serve those needs
    independently of governmental or corporate organization; and didactic,
    in that open-source software is not only a great source of utility but,
    perhaps more importantly, a potentially excellent source of educational
    material as well.
    
    For these reasons, many of [[Cat's Eye Technologies]]' software projects
    have been placed under permissive licenses and made available for public
    access on the Internet.  We generally favour the [[BSD license]], as we find
    it clear, succinct, and pointific.
    
    However, we also believe that it is important to recognize that the
    present culture of open source also has an ugly streak. Advocacy too
    often degrades into proselytizing, while philosophy is warped into
    doctrine. Dishearteningly, we believe that [Nikolai Bezroukov](http://www.softpanorama.org/)
    is justified in comparing these ideological tendencies to Lysenkoism.
    
    At Cat's Eye Technologies, we are attempting to counter this trend by
    being explicit about our reasons: We contribute to the pool of
    open-source software not because it is some kind of moral imperative,
    but simply because it is a good idea. We encourage others to do
    likewise.

Terminology:
  type: Concept
  commentary: |
    I'm sure everyone is familiar with the overuse of jargon in the computer
    industry. It's unfortunate, because it perpetuates a gulf of complexity:
    instead of helping others understand, it drives them away.
    
    The problem is not limited to practitioners making up words, though:
    there's no shortage of just plain abuse of language from researchers and
    theoreticians, too. Here are some examples.
    
    -   When we adjust a bound to make it *tighter*, say during an algorithm
        to compute the shortest path between two nodes in a graph, we call
        this *relaxation*.
    -   When we show that one problem is equivalent to another, *harder*
        problem, we say that we have *reduced* the easier problem to the
        harder one.
    -   When we connect two systems in a manner which *conceals* the details
        of how this connection is accomplished, we call this connection
        *transparent*.

Thue system:
  type: Concept
  description: |
    This is from Lewis & Papadimitriou, *Elements of the Theory of
    Computation*, 6.4.2. Thue Systems.
    
    A Thue system is a finite set of unordered pairs of strings that
    determines an equivalence relation on strings thusly: two strings are
    *equivalent* under the system if one can be transformed into the other
    by successively replacing substrings that are found as one member of
    some pair with the other member of that pair.
    
    The word problem for Thue systems is the problem of determining, given a
    Thue system J and two strings x and y, whether or not x and y are
    equivalent.
    
    The word problem for Thue systems is unsolvable. Moreover, there is a
    *fixed* Thue system J0 and a string w0 such that the problem of
    determining whether w is equivalent to w0 by J0 for an abritrary
    string w is also unsolvable.
    
    Thue systems are bidirectional in this sense: for every u → w, there is
    also a w ← u. A system which is unidirectional, in which the
    replacements only occur in one direction, is called a _semi-Thue system_.

Universality:
  type: Concept
  description: |
    We say an automaton is _universal_ if it can simulate any other automaton
    of the same kind.
    
    This definition depends, of course, on having suitable definitions of
    "simulate" and "kind", but these usually fall out naturally from the
    definition of the specific automaton under consideration.
    
    Probably the most well-known example of a universal automaton is the
    universal Turing machine, which, given a suitably encoded input, can
    simulate any other Turing machine. We say that such a universal Turing
    machine is Turing-complete. (Pedantically, we should say that it's the
    *set of strings* that the machine accepts which is Turing-complete. But
    for convenience, a certain amount of abuse of notation goes on.)
    
    Most [[Programming Language|programming languages]], or at least idealized
    versions of them, are universal; for example, you can write a
    [[Scheme]] interpreter in Scheme, and then run
    every Scheme program you can imagine on that interpreter.
    
    It's interesting to note that "every Scheme program you can imagine"
    includes that Scheme interpreter you just wrote — so you could run it on
    itself, and then run it on it running on it, etc, etc ad infinitum.
    Supporting automorphisms like this is a necessary, but not sufficient,
    condition for universality.
    
    It's also interesting to note that many different kinds of automata can
    simulate *each other*: there's a Turing machine that can interpret
    Scheme programs, and a Scheme program that can execute Turing machines.
    The fact that so many different kinds of automata can simulate each
    other in this way, and that no one has found some automaton that none of
    *them* can simulate, leads to what's called the Church-Turing thesis.
    (This is arguably a kind of "universality" as well, but we stress that
    it is a very different sense of "universal" than what we mean in this
    article.)
    
    Looking in the other direction, it's possible to show that, for many
    classes of automata there is no universal automaton. For example, there
    is no universal primitive-recursive function, no universal context-free
    grammar, and no universal finite-state automaton.
    
    It is not the case that only Turing machines can be universal. There
    are, for example, universal [[Cellular automaton|cellular automata]] which
    can simulate all other cellular automata. Note as well that cellular
    automata are unable to simulate Turing machines, since they cannot
    terminate.
    
    This last point is, incidentally, why we would argue that [Wolfram's 2-3
    Turing
    machine](http://en.wikipedia.org/wiki/Wolfram's_2-state_3-symbol_Turing_machine)
    is not, as he claims, "simpler" than Minsky's, or [Neary and
    Woods'](http://citeseer.ist.psu.edu/745708.html), universal Turing
    machines. Wolfram's rule 110 cellular automaton may be a universal
    cellular automaton, but any Turing machine which simulates it is not a
    universal Turing machine, because there are Turing machines which *do*
    halt, which it cannot simulate. The 2-3 machine could be made universal,
    perhaps, by giving it some capability to halt; but such a facility would
    surely increase its complexity, with no guarantee that it would still be
    "simpler" than the "reigning champions."

"Retrospective: Chris Pressey on Language Design":
  # XXX should be an article
  type: Concept
  description: |
    In contrast to [the list of languages I've designed](lingography.html),
    this is the page where I talk about what it's *like* to design languages
    and what my thoughts on certain languages and the design process are.
    
    ### Esolangs
    
    Mostly I design [esolangs](../about/esolang.html), which, in a nutshell,
    are programming languages that were never meant to be. On the surface,
    they appear to serve no purpose. You wouldn't use one for writing a
    "serious" program like an operating system or a text editor or a web
    service — unless you were quite mad, of course. They aren't academic
    research as we know it, either, because they don't aim to tell us
    anything about how software engineering can be improved.
    
    What they are, though, is *highly entertaining* — if you like that sort
    of thing — which many people do. If you're one of those people who likes
    programming *per se*, as a kind of intellectual challenge, then there's
    a chance you'll become good at it, and the possibilities presented by
    mainstream languages will begin to bore you. Solution? Try coding
    something in [INTERCAL](http://esolangs.org/wiki/INTERCAL),
    [Brainfuck](http://esolangs.org/wiki/Brainfuck), or
    [Befunge](http://esolangs.org/wiki/Befunge); and if those aren't weird
    enough for you, try [Homespring](http://esolangs.org/wiki/Homespring),
    or [Muriel](http://esolangs.org/wiki/Muriel), or [Please Porige
    Hot](http://esolangs.org/wiki/Please_Porige_Hot). Guaranteed to not be
    boring. And when you're really ready to test your mettle,
    [Malbolge](http://esolangs.org/wiki/Malbolge) will be waiting for you.
    
    They are also *things of beauty* — in their own right — if you can see
    it — which many people can. They are works of art. But the medium of
    programming language occupies a fairly unusual aesthetic position; any
    program written in some esolang is also potentially a work of art, and
    the program which implements the esolang — the interpreter or compiler —
    might well be a work of art too.
    
    Sometimes it seems like people sort themselves into groups based on
    these attributes. Some people like to write programs in esolangs
    (Brainfuck golf comes to mind,) some people like to design new and
    interesting esolangs, and some people like to implement esolangs. I am
    pretty squarely in the second group. While I am sometimes found
    implementing others' designs when they impress me, I generally lack the
    patience, concentration, stick-to-it-ive-ness, raw
    reasoning-inside-a-system ability, and quite frankly spare time it takes
    to puzzle together a working program in most esolangs. These days I find
    it quite challenging enough to merely compose example programs for my
    own esolangs.
    
    ### Quantity...
    
    I have, at this point, designed over 50 languages. Exactly how many
    depends on how you count. I don't consider Illgola-2, Illberon, or
    Ilgol\#\# to be different languages from
    [ILLGOL](lingography.html#illgol) — I've even gone back and forth on
    whether they should live in the same project or not. I don't consider
    Jacciata to be significantly different from
    [Jaccia](lingography.html#jaccia); I'm not sure about
    [2iota](lingography.html#2iota) and [beta-Juliet and
    Portia](lingography.html#b_juliet) (or should even that pair count as
    two?) On the other hand, I do see
    [Befunge-93](lingography.html#befunge93) and
    [Befunge-98](lingography.html#funge98) as being quite different, as are
    say [Emmental](lingography.html#emmental) and
    [Mascarpone](lingography.html#mascarpone), and
    [Arboretuum](lingography.html#arboretuum) and
    [Treacle](lingography.html#treacle). And when you get into language
    families, well, arguably [Funge-98](lingography.html#funge98) only has 3
    viable members, but there is really no limit to the number of
    [Didigms](lingography.html#didigm) there are.
    
    Yet I do consider my cellular automata to be languages. Partly because
    some of them have roots in systems that were more clearly processor-, if
    not language-, like: [REDGREEN](lingography.html#redgreen) is an
    adaptation of [RUBE](lingography.html#rube) to CA, just as
    [Braktif](lingography.html#braktif) is an adaptation of Brainfuck, or
    [Circute](lingography.html#circute) is an adaptation of circuitry.
    Partly because they are Turing-equivalent systems in which problems can
    be expressed and solved, just as they can in run-of-the-mill programming
    languages.
    
    ### ...and Qualities
    
    However, I am not by any means the most prolific language designer out
    there. In fact, for sheer numbers, I seem to be in third place, behind
    [Wouter "Aardappel" van Oortmerssen](http://strlen.com/) and [Aaron
    "zzo38" Black](http://zzo38computer.cjb.net/). But sheer numbers aren't
    everything. Unlike zzo38, the majority of my designs have been
    implemented, and unlike Wouter, the majority of my designs and
    implementations are publicly available from [my website](/).
    
    So I might be led to consider other ways to measure my success as a
    language designer. What about popularity? Alas, it seems that I am third
    in that arena too; the inevitable roll call of canonical esolangs seems
    to be INTERCAL, then Brainfuck, then Befunge (see, even I followed that
    sequence, above.) But, perhaps we will find a measure which is subtler
    still, if we examine influence. While Brainfuck is the clear winner
    here, with dozens and dozens of descendants and variants both major and
    minor, (and yes, I have done a couple of these myself), I have the
    distinction of having several of my languages inspire designs and
    implementations and such by others, a fact by which I am flattered. For
    instance, [Befunge](lingography.html#befunge93) has been implemented
    dozens of times, and has influenced
    [Blank](http://esolangs.org/wiki/Blank),
    [Befreak](http://esolangs.org/wiki/Befreak),
    [PATH](http://esolangs.org/wiki/PATH), and
    [Aheui](http://esolangs.org/wiki/Aheui), among others;
    [RUBE](lingography.html#rube) found its way into [RUBE
    II](http://catseye.tc/projects/rube_ii/), [RubE On Conveyor
    Belts](http://esolangs.org/wiki/RubE_On_Conveyor_Belts), and
    [Rubicon](http://kevan.org/rubicon/);
    [SMETANA](lingography.html#smetana) inspired a FSM-completeness proof in
    the form of [Smallfuck](http://esolangs.org/wiki/Smallfuck); and
    [SMITH](lingography.html#smith) begat
    [SMITH\#](http://esolangs.org/wiki/SMITH_sharp) and
    [SMITHb](http://esolangs.org/wiki/SMITHb). Even
    [Xigxag](lingography.html#xigxag) seems to have attracted some attention
    (and shorter proofs than my own).
    
    ### A Matter of Taste
    
    What makes a "good" esolang? I'm not sure, but I have some opinions. For
    starters, to take Brainfuck and to replace each instruction with a
    different barnyard sound is... well, as Jeeves would say, I should
    scarcely advocate it. At the same time, I rail against the idea of
    reducing languages to "just semantics"; a delicate touch with the syntax
    is what makes a good language outstanding, esolang or otherwise.
    
    Languages I design tend to fall into a couple of groups. One is the
    straight-up parody language, making fun of the absurdity of computer
    programming or some other ridiculous activity.
    [ILLGOL](lingography.html#illgol) is probably the canonical example, but
    [HUNTER](lingography.html#hunter), [N'DCNC](lingography.html#n-dcnc),
    [Jaccia](lingography.html#jaccia) and maybe
    [Sbeezg](lingography.html#sbeezg) count, too.
    
    Another group are the "merely interesting" languages which don't really
    count as esolangs because they're just too normal, perhaps even
    attempting to solve a practical problem; this would include at least
    [ETHEL](lingography.html#ETHEL), [Bhuna](lingography.html#bhuna),
    [Iphigeneia](lingography.html#iphi),
    [Arboretuum](lingography.html#arboretuum),
    [Treacle](lingography.html#treacle), and
    [Dieter](lingography.html#dieter), and anything I design any time I
    start getting fed up with the state of modern mainstream languages and
    think I can do better. (I don't usually try to publish those.)
    
    A third group is made up of "strange exercises"; languages which are
    designed around some principle which turns out to have unusal effects.
    This could include [Sally](lingography.html#sally),
    [Larabee](lingography.html#larabee),
    [Mascarpone](lingography.html#mascarpone), and
    [Unlikely](lingography.html#unlikely).
    
    But probably my favourite design category is the "impossible language".
    Pick a combination of features which appears absurd and contradictory,
    like an Escher staircase or a de Chirico piazza, and in implementing it,
    tease out a labrythine connection which allows it to exist. Whether that
    be a machine language with no branch instructions — none at all — like
    [SMITH](lingography.html#smith), or a non-deterministic imperative
    language like [Strelnokoff](lingography.html#strelnokoff), or a conlang
    without word order like [Opus-2](lingography.html#opus-2), or a language
    with only infix operators but no precedence table like
    [Hev](lingography.html#hev), or a Turing-equivalent language with only
    `foreach` like [Quylthulg](lingography.html#quylthulg), or a language
    with memory-mapped loops like [ZOWIE](lingography.html#zowie), or a
    language where the only means of control flow is throwing and catching
    lexical exceptions like [Okapi](lingography.html#Okapi), or an
    imperative string-rewriting language like Pophery (under
    construction)... the results are usually highly entertaining.
    
    What are my favourite esolangs, you ask? Well, the three I listed
    earlier (Homespring, Muriel, and Please Porige Hot) hold special places
    in my heart. The favourite esolangs of my *own* is a much harder
    question to answer. I will say that, in terms of striking a balance
    between "challenge to code in" and "beauty", I think
    [Mascarpone](lingography.html#mascarpone) is one of my best. That
    doesn't necessarily mean it's my favourite, though.
    
    ### The Design Process
    
    I should really say something about the design process itself. One thing
    I can point out is how long it typically takes to design a language;
    it's usually measured in years. It starts with an idea, of course. But
    ideas are a dime a dozen, and it's recognizing the good ones, the ones
    that fall in some relatively narrow zone between "too weird" and "not
    weird enough", that's the hard part. Then the challenge is not
    forgetting the idea, which usually means writing it down before your
    brain is engaged in other pursuits. Sometimes it comes back if you
    don't, but not always. Sometimes you can't reconstruct it from what you
    wrote down, either, but usually you can.
    
    After the idea has proven promising enough to make it into the notebook,
    there comes a period of time known as development. The idea is almost
    never a full-formed language, so it must grow into one, although
    sometimes it [never reaches that stage](louie.html). This is actually
    why I try to implement my designs whenever I can; implementation fleshes
    out the grey areas and lays bare any places where the design falls
    apart. It usually leads to a more solid theme or paradigm inside the
    design, too, as the implementation phase generally alternates between
    (re)implementation and (re)design.
    
    And this process, as I said, takes years. This is largely because I hold
    down a full-time job and spend much of my time maintaining a household
    too, so there is a tight limit on the amount of time I can spend. It is
    also largely because at any given time I am working on a dozen different
    designs "breadth-first", and must split my attention between them.
    However, there is also something to the idea that a design must age,
    like wine, to be really good. If the small amount of initial work I may
    have done on something still interests me a year later, I have a better
    feeling that it is worth finishing. Also, many designs accumulate small
    changes over time as I look at them from different angles, while others
    are simply difficult to fully conceive or implement —
    [Burro](lingography.html#burro) and [Okapi](lingography.html#Okapi) come
    immediately to mind.
