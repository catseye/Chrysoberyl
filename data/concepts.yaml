# encoding: UTF-8
# this one's a real grab-bag, for now

Galois connection:
  type: Concept
  description: |
    A Galois connection is a pair of complementary maps with certain
    properties between a pair of complementary sets.
    
    Galois connections provide a mathematical basis for abstract
    interpretation, and they are possibly easiest to understand from
    examples given in that context.
    
    We can think of our pair of sets as being a set of *concrete* values
    (such as {0, 1, 2, ... }) and a set of *abstract* values (such as
    {`int`, `even`, `odd`, `power-of-two`, `prime`, ... }).
    
    We then think of our pair of maps as being an *abstractifying* map which
    takes elements of the concrete value set and sends them to elements of
    the abstract value set, and a *concretizing* map which takes elements of
    the abstract value set and sends them to elements of the concrete value
    set.
    
    This pair of maps is a Galois connection when, if some abstract value
    (such as `even`) maps to some set of concrete values (such as {2, 4, 6,
    8, ... }), then any concrete value in that set (such as 8) also maps to
    some (possibly specialized) instance of the abstract value (such as
    `power-of-two`).
    
    That's not quite the whole story, but it seems like the most intuitive
    version to me.
    
    Now there's nothing saying that the sets have to be "abstract" or
    "concrete" or that the maps have to be "abstractifying" or
    "concretizing" -- those are just from this one application in abstract
    interpretation. On the other hand, the structure inherent in the Galois
    connection does lend itself to relationships like this.


Open-source:
  type: Concept
  commentary: |
    We believe that open-source software has an important civic and didactic
    role in modern society. Civic, in that with it, communities of
    individuals with common software needs can serve those needs
    independently of governmental or corporate organization; and didactic,
    in that open-source software is not only a great source of utility but,
    perhaps more importantly, a potentially excellent source of educational
    material as well.
    
    For these reasons, many of [[Cat's Eye Technologies]]' software projects
    have been placed under permissive licenses and made available for public
    access on the Internet.  We generally favour the [[BSD license]], as we find
    it clear, succinct, and pointific.
    
    However, we also believe that it is important to recognize that the
    present culture of open source also has an ugly streak. Advocacy too
    often degrades into proselytizing, while philosophy is warped into
    doctrine. Dishearteningly, we believe that [Nikolai Bezroukov](http://www.softpanorama.org/)
    is justified in comparing these ideological tendencies to Lysenkoism.
    
    At Cat's Eye Technologies, we are attempting to counter this trend by
    being explicit about our reasons: We contribute to the pool of
    open-source software not because it is some kind of moral imperative,
    but simply because it is a good idea. We encourage others to do
    likewise.

Terminology:
  type: Concept
  commentary: |
    I'm sure everyone is familiar with the overuse of jargon in the computer
    industry. It's unfortunate, because it perpetuates a gulf of complexity:
    instead of helping others understand, it drives them away.
    
    The problem is not limited to practitioners making up words, though:
    there's no shortage of just plain abuse of language from researchers and
    theoreticians, too. Here are some examples.
    
    -   When we adjust a bound to make it *tighter*, say during an algorithm
        to compute the shortest path between two nodes in a graph, we call
        this *relaxation*.
    -   When we show that one problem is equivalent to another, *harder*
        problem, we say that we have *reduced* the easier problem to the
        harder one.
    -   When we connect two systems in a manner which *conceals* the details
        of how this connection is accomplished, we call this connection
        *transparent*.

Thue system:
  type: Concept
  description: |
    This is from Lewis & Papadimitriou, *Elements of the Theory of
    Computation*, 6.4.2. Thue Systems.
    
    A Thue system is a finite set of unordered pairs of strings that
    determines an equivalence relation on strings thusly: two strings are
    *equivalent* under the system if one can be transformed into the other
    by successively replacing substrings that are found as one member of
    some pair with the other member of that pair.
    
    The word problem for Thue systems is the problem of determining, given a
    Thue system J and two strings x and y, whether or not x and y are
    equivalent.
    
    The word problem for Thue systems is unsolvable. Moreover, there is a
    *fixed* Thue system J0 and a string w0 such that the problem of
    determining whether w is equivalent to w0 by J0 for an abritrary
    string w is also unsolvable.
    
    Thue systems are bidirectional in this sense: for every u → w, there is
    also a w ← u. A system which is unidirectional, in which the
    replacements only occur in one direction, is called a _semi-Thue system_.

Universality:
  type: Concept
  description: |
    We say an automaton is _universal_ if it can simulate any other automaton
    of the same kind.
    
    This definition depends, of course, on having suitable definitions of
    "simulate" and "kind", but these usually fall out naturally from the
    definition of the specific automaton under consideration.
    
    Probably the most well-known example of a universal automaton is the
    universal Turing machine, which, given a suitably encoded input, can
    simulate any other Turing machine. We say that such a universal Turing
    machine is Turing-complete. (Pedantically, we should say that it's the
    *set of strings* that the machine accepts which is Turing-complete. But
    for convenience, a certain amount of abuse of notation goes on.)
    
    Most [[Programming Language|programming languages]], or at least idealized
    versions of them, are universal; for example, you can write a
    [[Scheme]] interpreter in Scheme, and then run
    every Scheme program you can imagine on that interpreter.
    
    It's interesting to note that "every Scheme program you can imagine"
    includes that Scheme interpreter you just wrote — so you could run it on
    itself, and then run it on it running on it, etc, etc ad infinitum.
    Supporting automorphisms like this is a necessary, but not sufficient,
    condition for universality.
    
    It's also interesting to note that many different kinds of automata can
    simulate *each other*: there's a Turing machine that can interpret
    Scheme programs, and a Scheme program that can execute Turing machines.
    The fact that so many different kinds of automata can simulate each
    other in this way, and that no one has found some automaton that none of
    *them* can simulate, leads to what's called the Church-Turing thesis.
    (This is arguably a kind of "universality" as well, but we stress that
    it is a very different sense of "universal" than what we mean in this
    article.)
    
    Looking in the other direction, it's possible to show that, for many
    classes of automata there is no universal automaton. For example, there
    is no universal primitive-recursive function, no universal context-free
    grammar, and no universal finite-state automaton.
    
    It is not the case that only Turing machines can be universal. There
    are, for example, universal [[Cellular automaton|cellular automata]] which
    can simulate all other cellular automata. Note as well that cellular
    automata are unable to simulate Turing machines, since they cannot
    terminate.
    
    This last point is, incidentally, why we would argue that [Wolfram's 2-3
    Turing
    machine](http://en.wikipedia.org/wiki/Wolfram's_2-state_3-symbol_Turing_machine)
    is not, as he claims, "simpler" than Minsky's, or [Neary and
    Woods'](http://citeseer.ist.psu.edu/745708.html), universal Turing
    machines. Wolfram's rule 110 cellular automaton may be a universal
    cellular automaton, but any Turing machine which simulates it is not a
    universal Turing machine, because there are Turing machines which *do*
    halt, which it cannot simulate. The 2-3 machine could be made universal,
    perhaps, by giving it some capability to halt; but such a facility would
    surely increase its complexity, with no guarantee that it would still be
    "simpler" than the "reigning champions."
