# encoding: UTF-8
POSIX:
  type: Platform
  wikipedia: POSIX
  specification-link: https://www2.opengroup.org/ogsys/catalog/T101
  development-stage: mature
  # sigh
  native-language: x86 machine code
  # sh might count, I'm not sure what else would, though
  other-languages: []
  references:
  - url: http://standards.ieee.org/develop/wg/POSIX.html
    title: IEEE POSIX group
    description: Gatekeepers of the specification
  - url: http://www.unixpapa.com/incnote/
    title: Unix Incompatibility Notes
    description: Notes on quirks and variations between different Unices
  - url: http://www.art.net/~hopkins/Don/unix-haters/handbook.html
    title: UHH
    description: The Unix Hater's Handbook (Author's page)
  - url: http://web.mit.edu/~simsong/www/ugh.pdf
    title: UGH
    description: The Unix Hater's Handbook (Fulltext, PDF)

Linux:
  type: Implementation
  implementation-of:
  - POSIX
  host-language: C99
  implementation-type: operating system
  license: GPL
  # guhhh...
  standards-body: http://linux.com/
  development-stage: mature
  generally-recommended: true
  prebuilt-for-platforms:
  - IBM PC compatible


FreeBSD:
  type: Implementation
  implementation-of:
  - POSIX
  host-language: C99
  implementation-type: operating system
  standards-body: http://freebsd.org/
  # natch
  license: BSD license
  development-stage: mature
  prebuilt-for-platforms:
  - IBM PC compatible
  references: 
  - title: BSDAsm
    description: FreeBSD Assembly Language Programming
    url: http://www.int80h.org/bsdasm/
  - title: FreeBSD System Programming
    description: A book about system programming under FreeBSD
    url: http://www.khmere.com/freebsd_book/


NetBSD:
  type: Implementation
  implementation-of:
  - POSIX
  implementation-type: operating system
  host-language: C99
  standards-body: http://netbsd.org/
  # natch
  license: BSD license
  development-stage: mature
  prebuilt-for-platforms:
  - IBM PC compatible


Cygwin:
  type: Implementation
  implementation-of:
  - POSIX
  implementation-type: emulator
  prebuilt-for-platforms:
  - Windows
  # guess
  host-language: C99
  # guess (i know it's actually more restrictive in some ways)
  license: GPL
  links:
  - http://www.cygwin.com/
  description: |
    Cygwin is a compatibility layer for Windows
    which lets you build and run software which expects a Unix-like
    operating system.
  commentary: |    
    Cygwin is really nice when you're stuck using Windows, but you want to
    play with [open-source software](opensource.html), most of which expects
    to be run on a Unix-like operating system.
    
    But there is one annoying thing about Cygwin: in its default install,
    you have to use it through a console window, of the kind provided by
    Windows for running Command Prompt. The editing capabilities and general
    usability of this console window are just short of atrocious.
        
    Fortunately, on modern Windowses, you're not stuck with this: you can
    make Cygwin use a PowerShell window. While not paradise, it's not quite
    as frustrating to use. Here's how to set it up:
    
    1.  Find PowerShell on your Windows installation. The easiest way to do
        this is probably to use the search facility in the Start menu, and
        type in `powershell`.
    2.  Once you find an icon for PowerShell, create a shortcut for it.
        Alt-drag it to the desktop or something.
    3.  Edit the properties of that shortcut. The target will be something
        like `%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe`.
        Add the location of your `cygwin.bat` file to it, so that it's
        something like:
        `%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe C:\cygwin\cygwin.bat`.
    4.  Probably you should rename your shortcut "Cygwin Powershell" or
        something, to minimize confusion.
    5.  Double-click your new shortcut. It should totally just work.
    
    (Update: recent versions of Cygwin come with a new dedicated Cygwin
    terminal, which is much less atrocious than the default Windows console.
    Still, the PowerShell has properties which may prove attractive -- not least
    of which is its awesome, awesome name.)


MS-DOS:
  type: Platform
  standards-body: http://microsoft.com/
  development-stage: vintage
  native-language: x86 machine code
  other-languages:
  - MS-DOS Batchfile
  description: |
    An operating system of old; you may have heard of it?
  commentary: |
    I think the only thing of mine that requires MS-DOS anymore is
    [[Shelta]]; and even then, it might rely only on the BIOS interface,
    I forget.
   
    A project which has this as a dependency
    assumes that it will be running under MS-DOS or something
    which emulates MS-DOS sufficiently well. This includes both the standard
    DOS INT 21h handler, and the standard DOS utilies like, for example,
    DEBUG.COM.
    
    You can try (at your own risk, of course) using the project under some
    more-or-less modern version of [[Windows]] and hope that it emulates DOS
    well enough to work. It might, it might not. If not, you have options:
    
    *   [[DOSBox]] is an emulator, available for many systems, which
        simulates both an [[IBM PC compatible]], and
        MS-DOS on top of it.  It should be plenty sufficient for running
        DOS-based software found here.
    *   For a more heavyweight solution, you could install [[FreeDOS]]
        on a PC emulator such as [[QEMU]].
    
    All of the above software packages are [[Open-source|open source]].
  references:
  - url: http://www.delorie.com/djgpp/
    title: DJGPP
    description: DJ Delorie's port of GCC to MS-DOS
  - url: http://ftp.lanet.lv/ftp/mirror/x2ftp/msdos/programming/
    title: x2ftp
    description: MS-DOS game programming archive

DOSBox:
  type: Implementation
  implementation-of:
  - MS-DOS
  implementation-type: emulator
  prebuilt-for-platforms:
  - native code
  generally-recommended: true
  host-language: C++
  license: GPL
  links:
  - 'http://www.dosbox.com/'

FreeDOS:
  type: Implementation
  implementation-of: 
  - MS-DOS
  implementation-type: emulator
  prebuilt-for-platforms:
  - IBM PC compatible
  # a guess
  host-language: C99
  license: GPL
  links:
  - 'http://www.freedos.org/'

MS-DOS Batchfile:
  type: Programming Language
  genre: Production language
  standards-body: http://microsoft.com/
  development-stage: mature
  paradigms: []
  authors: []


Windows:
  type: Platform
  standards-body: http://microsoft.com/
  development-stage: mature
  native-language: x86 machine code
  other-languages:
  - VBScript
  references:
  - url: http://www.piclist.com/techref/os/win/api/index.html
    title: Win32 API Reference
    description: API Reference for Win32
  - url: http://www.winprog.org/tutorial/
    title: Win32 tutorial
    description: theForger's Win32 API programming tutorial
  - url: http://www.piclist.com/techref/language/asm/win32asm.htm
    title: Win32Asm
    description: Windows Assembly Language Programming
  - url: http://www.autohotkey.com/docs/misc/Styles.htm
    title: GUI Styles
    description: Brief descriptions of Windows GUI constants

WINE:
  type: Implementation
  implementation-of:
  - Windows
  implementation-type: emulator
  prebuilt-for-platforms:
  - POSIX
  # by which I mean Linux and friends
  host-language: C++
  license: GPL

VBScript:
  type: Programming Language
  genre: Production language
  member-of: BASIC
  standards-body: http://microsoft.com/
  development-stage: mature
  paradigms:
  - Object-oriented
  authors: []


AmigaDOS 1.3:
  type: Platform
  wikipedia: AmigaDOS
  specification-link: 'http://www.pagetable.com/docs/amigados_tripos/amigados_manual.pdf'
  development-stage: vintage
  native-language: 68000 machine code
  other-languages:
  - AmigaBasic

AmigaBasic:
  type: Programming Language
  genre: Production language
  member-of: BASIC
  standards-body: http://microsoft.com/
  development-stage: vintage
  paradigms:
  - Imperative
  authors: []


HTML5:
  type: Platform
  # this'll do, for now
  specification-link: http://dev.w3.org/html5/spec/single-page.html
  # and let's be quite honest
  development-stage: work in progress
  # errr... close enough
  native-language: Javascript
  # there ARE others, but I don't care.
  other-languages: []
  commentary: |
    In a way that is directly or indirectly appropriate to the number 5,
    the HTML5 standard makes a mockery of the very idea of a standard
    by being a "living standard".
    
    On top of this, HTML5 is the [[Perl]] of web standards, which is
    to say, it's like playing [[Katamari Damacy]] with the web.  From what
    I can tell, the standardization process goes something like this:
    
    *   Pick a feature, any feature.
    *   Does any browser currently support that feature?
        *   If so, research how all browsers implement that feature.
            Codify the upper bound of that behaviour and put it in the spec.
        *   If not, would the feature be *totally awesome* to have anyway?
            *   If so, codify that feature and add it to the spec.
                Don't worry too much if browsers implement it yet or not;
                someone will write a polyfill anyway.  Let browsers use
                words like "maybe" and "probably" to describe their
                level of support for the feature.
            *   If not, try again.
    
    The number one best thing about HTML5, in my opinion, is the
    `<canvas>` element.  At long last, I can just _draw stuff_ on a web page,
    and that's actually really nice.
