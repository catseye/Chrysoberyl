# encoding: UTF-8
# actually some of these do have reference distributions
ANSI C:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  reference-link: http://clc-wiki.net/wiki/C89
  references: 
  - title: ANSI C docs
    description: Interesting documents about the standardization of C
    url: http://www.lysator.liu.se/c/
  as-a-prerequisite: |
    The C-language source files in this project conform to C89 (also,
    and more popularly, known as ANSI C.)
    We usually test them with [gcc 3.4](http://gcc.gnu.org/gcc-3.4/),
    but they may work with a gcc version as old as
    [gcc 2.95.3](http://gcc.gnu.org/gcc-2.95/), as well. 
    
    The souce files compile with the `-ansi` flag (and usually `-pedantic`,
    too,) and should (in theory at least) be buildable with any ANSI C
    compiler.
    
    Many of our C projects will compile both as [[C99]] and as
    ANSI C (perhaps omitting some features) by passing the environment
    variable `ANSI=yes` to `make`.

C99:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  reference-link: http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf
  links:
  - http://gcc.gnu.org/gcc-3.4/
  - http://www.opengroup.org/onlinepubs/9699919799/
  as-a-prerequisite: |
    The C-language source files in this project conform to the C99 standard.
    These souce files generally are such that they *would* compile with the
    `-ansi` flag *except* that they rely on libraries specified by the Single
    UNIX Specification version 3 (also, and more popularly, known as POSIX)
    to provide access to resources such as clock information and network sockets.
    
    Most modern UNIX-like operating systems implement something
    approximating the POSIX interface. For Windows, compatibility layers
    such as [[Cygwin]] fill this role.
    
    Note that the specification linked to is actually SUSv7, which is very
    similar to SUSv3, but unlike SUSv3 has freely-accessible documentation
    on the web.
    
    Many of our C projects will compile both as C99 and as
    [[ANSI C]] (perhaps omitting some features) by passing the environment
    variable `ANSI=yes` to `make`.

C++:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  references:
  - title: C++ FAQ Lite
    description: Comprehensive compilation of C++ questions and answers
    url: http://www.parashift.com/c++-faq-lite/
  - title: C++ FQA Lite
    description: 'A "Rebuttal" to C++ FAQ Lite: Frequently Questioned Answers'
    url: http://yosefk.com/c++fqa/
  - title: STL
    description: SGI's Standard Template Library Programmer's Guide
    url: http://www.sgi.com/tech/stl/index.html
  - title: Boost
    description: Boost provides free peer-reviewed portable C++ source libraries
    url: http://www.boost.org/
  - title: TFoo::operator=
    description: The Anatomy of the Assignment Operator
    url: http://icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html
  commentary: |
    For any software project, it's important that you choose the right
    language to develop it in. That's why you'll always choose C++, no
    matter what the project is!
    
    Why will you choose C++? Because it's popular, so a lot of programmers
    know it. And a lot of programmers means a lot of competition, and that
    means you'll be able to hire programmers at the lowest rate! This will
    surely offset whatever costs might be incurred from choosing an
    ill-suited programming language and hiring programmers who work at the
    lowest rate.
    
    And why *is* C++ such a popular programming language?
    
    Is it because it's a good programming language? Hardly. That's like
    saying that coffee is a popular beverage because it's healthful.
    
    No, C++ is popular because C++ is popular. Hey, Google is a big,
    successful company, and I hear they use C++... it must be *why* they're
    successful! You should use C++ too!
    
    But that's not the only reason. C++ is popular because programmers
    *like* it. I suppose the question then is, *why* do programmers like it?
    
    Is it because C++ makes it easy to write correct, maintainable code? Is
    it because C++ is easy to learn? Is it because there are things you can
    do in C++ that you can't do in any other language? Is it that C++ lets
    your programs run as fast as they possibly can?
    
    Anyone who has ever used C++ can tell you the answer to all of those
    questions: No. (No, not even when it comes to making your program run as
    fast as it can. C++ allows so much control over the low-level workings
    of the program that the compiler cannot make optimizations that it
    otherwise could, if the programmer were constrained to working at a
    higher level of abstraction.)
    
    So what is it about C++ that makes programmers like it?
    
    Well, I have a theory. While most "normal" people feel that their lives
    are too complicated, too full of arbitrary rules and boring details and
    essentially meaningless things to remember, there's a certain strain of
    psychology that actually *thrives* on complexity like this, because such
    complexity *generates gratuitous expertise*.
    
    What I mean by this is that if a system is easy to master, then there's
    no opportunity to show off your mastery of it. There's no way to display
    your dominance through your command of minutiae and knowledge of trivia.
    And if that's what really motivates you, then, well, you're going to
    avoid that system, because it doesn't provide you anything to work with
    in the social game you want to play. Instead, you'll look for something
    with a lot of nooks and crannies and bells and whistles and jargon and
    buzzwords that you can familiarize yourself with, and you'll take every
    opportunity to demonstrate that you are More Familiar with It than Thou.
    You'll look for something like... well, like C++.
    
    And if it so happens that programmers with this general personality type
    *also* like the idea of *total control over their program* — and while
    I'm no expert on psychology, somehow that seems likely — C++'ll have'em
    downright hooked.

CSS:
  type: Programming Language
  genre: Production language
  paradigms:
  - Declarative
  computational-class: unknown computational class
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    If I, as a programmer, were to tell you that CSS is the ultimate hacking
    language, would you be surprised? After all, it's not even a
    [Programming Language], really. But that doesn't really
    matter, does it? It meets the only possible criterion there could be for
    the ultimate hacking language: in order to achieve the effect that what
    you want, you have to hack and hack and hack...
    
    So, I have a question. If CSS is so superior to [those awful tables
    which should never ever be used for
    layout](http://phrogz.net/CSS/HowToDevelopWithCSS.html#tables), how come
    a simple and much desired three-column layout, so trivial to construct
    with a table, is considered [one of the holy grails of
    CSS](http://www.alistapart.com/articles/holygrail)?
    
    Seems that the real solution to this would be to have some set of
    elements that has the layout behaviour of tables but without the "treat
    this as tabular data, would you please" semantics. I suppose that's what
    `display: table-cell` *et al* is for — if only more browsers supported
    it.
    
    I kvetch, but there *is* one very nice thing about CSS: unlike
    [[Javascript]], it's declarative, and nowhere near as
    [powerful as a Turing machine](universality.html). So, it might make
    your page look ugly in nine out of ten browsers six out of seven days of
    the week, but at least it probably won't hang, or crash, or corrupt the
    browser's state.

Erlang:
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  references:
  - title: Open Source Erlang/OTP
    description: Ericsson's official distribution site
    url: http://www.erlang.org/
  as-a-prerequisite: |
    Some or all of the programs in this project are Erlang modules, and
    running them requires a copy of the Erlang/OTP runtime system, version
    R13B03 or later, or a fully-compatible runtime system.
    
    Note that compiled Erlang modules are `.beam` files in the `ebin`
    directory. The source code lives in the `src` directory, and an Erlang
    compiler (such as the one which ships with Erlang/OTP) is required to
    build the modules.
    
    Also note that the `.beam` files will have to be recompiled in order to
    run under recent versions (e.g. R13B) of Erlang/OTP, as the
    binary format has changed.
    
    Also note there is a good chance that the sources will compile and run
    on an older version (say, R9C) of Erlang/OTP, but you may need
    to make some manual changes and system setup.

Haskell:
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  - Lazy
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - http://www.haskell.org/
  - http://www.haskell.org/ghc/
  - http://www.haskell.org/hugs/
  as-a-prerequisite: |
    Any Haskell 98-conforming implementation of Haskell should be able to
    handle the sources for this project. In order to compile a binary with a
    Haskell compiler such as `ghc`, you may need to add some driver code.

Java:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  references:
  - title: Oracle Technology Network > Java
    description: Official website of the Java™ Platform
    url: http://www.oracle.com/technetwork/java/index.html
  - title: Java Specs
    description: The Java™ Virtual Machine and Language Specifications
    url: http://docs.oracle.com/javase/specs/
  as-a-prerequisite: |
    Java SE 6 JDK 1.6.0
    
    Some or all of the programs are written in Java 6 source code, and
    creating Java classes from them requires a copy of the Java Development
    Kit, version 1.6.0 or later, or a fully-compatible compilation
    environment.
    
    Note that the Java source code lives in the project's `src` directory,
    and a Java compiler such as the one which ships with JDK 1.6.0 is
    required to build the class files from the sources.
    
    Java SE 6 JRE 1.6.0
    
    Some or all of the programs this project are implemented by Java 6
    classes, and running them requires a copy of the Java Runtime
    Environment, version 1.6.0 or later, or a fully-compatible runtime
    environment.
    
    Note that compiled Java classes are `.class` files in some subdirectory
    of the project's `bin` directory.

Javascript:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  description: |
    Javascript (also and more properly known as ECMAScript) is a
    [[Programming Language]] that some web browsers implement
    in order to let scripts control the dynamic behaviour of a web page,
    such as what happens when the user clicks on some region of text.
  commentary: |    
    We at [[Cat's Eye Technologies]] have long taken a dim view of this
    predominant application of Javascript. It's gratuitous; web pages exist
    in order to convey information, not be playthings. Managing the user
    interface is the *browser*'s job; what makes the *page* think it can do
    it better? But more to the point, putting a
    [[shown Turing-complete]] control language in a browser is a
    way to let web pages be just as impossible to predict, and just as
    buggy, as general computer programs. Multiply this by the number and
    degree of variations between Javascript specifications and
    implementations to experience the full hellishness of this fact.
    
    Or, as we used to say, *web pages shouldn't crash your browser*.
    
    But we also admit that Javascript, used judiciously, can improve the
    usability of a web page.
    
    So we have decided to compromise. Our policy regarding Javascript is as
    follows.
    
    -   *If you don't like it, turn it off.*
    
        Everything on this website is navigable even with Javascript
        disabled. (It even looks acceptable without styling. So if you don't
        like our far-out background graphics, or you want the genuine
        experience of surfing the web circa 1996, try turning off
        [[CSS]] too.) If you're using a browser that doesn't allow
        you to disable these features, you might want to consider why you
        chose to use a tool that takes that power away from you.
    
    -   *Use commodity components.*
    
        As much as we like to "roll our own" computational stuff here at
        Cat's Eye Technologies, the application domain of Javascript
        generally makes that option too risky. Correct Javascript must not
        only encode a correct algorithm, it must correctly account for
        differences between Javascript implementations and browsers. In
        addition, being interactive, any incorrect Javascript will have a
        direct negative impact on the user experience.
    
        So what we do is we use commodity components -- open-source
        Javascript modules that are community-developed. The broad base of
        users and developers helps ensure that the scripts are tested both
        deeply and broadly (that is, across a large cross-section of
        browsers.)
    
    -   *Keep it simple, stupid.*
    
        When writing our own Javascript is unavoidable, we keep it as simple
        as possible. Is there a way to write it that doesn't involve a loop?
        Is there a way to accomplish the same thing using stylesheets
        instead? Does the interactive feature actually not make the site
        more usable? If the answers to any of these are "yes" then there's a
        good chance that the script they're being asked about won't get
        written.

Lua:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  references:
  - title: Lua
    description: Official Lua website
    url: http://www.lua.org/
  reference-link: http://www.lua.org/versions.html#5.0
  as-a-prerequisite: |
    Some or all of the programs in this project are Lua scripts, and running
    them requires a Lua interpreter, version 5.0.x. (The latest version, as
    of this writing, is 5.0.3, and this version is recommended. Note that
    the 5.1.x series of Lua is not generally compatible with the 5.0.x
    series.)
    
    While there are several implementations of Lua, we're not aware of any
    standards documents defining the language aside from the reference
    implementation produced by the Lua project, which we've linked to here.

MSIL:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  computational-class: unknown computational class
  has-reference-distribution: false
  implementations: []
  authors: []

Perl:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - http://www.cpan.org/ports/
  as-a-prerequisite: |
    Some or all of the programs in this project are Perl scripts, and
    running them requires a Perl interpreter, version 5.8.8 or later. We'll
    try to make sure they still run the same on later 5.x versions of Perl,
    but we won't make any guarantees there.
    
    We're not aware of any implementation of Perl which conforms to version
    5.8.8 that isn't based on Larry Wall's source base, so that's the link
    we've given here.
  commentary: |
    Perl is what happens when you play [[Katamari Damacy]]
    with the Unix toolchain.
    
    Ah, but the world should thank Perl for being the experiment that
    demonstrated the effect of [designing a programming language around
    natural-language principles](http://www.wall.org/~larry/natural.html)
    (because for some reason, we learned so little from COBOL.) And of
    course we should thank the experimenters for being so candid and
    unbiased about their results. Finally, we have data that shows us what
    we already knew, namely that [programming, no, "scripting" is really a
    fuzzy endeavour](http://www.perl.com/pub/a/2007/12/06/soto-11.html) —
    much like talking, or thinking. This is why Perl scripts, and by
    extension all computer programs, have so few bugs.
    
    But if you can psychologically overcome all of that — perhaps with the
    aid of some sort of nuclear-powered ninja weaponry — Perl's not *that*
    bad. Unlike [[C++]], it has garbage collection. It has
    anonymous [function closures](closures.html) (unlike [[PHP]],)
    and they can consist of more than one expression (unlike [[Python]].) And
    things like `use strict` at least smell like an attempt to approach some
    sort of trying to permit, I don't know, enforcing discipline, or
    something, if you think that would help.

PHP:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    PHP is language defined by a tool built by some guys who saw a
    [[Perl]] interpreter once and thought it was really neat. They
    thought that it would just *rock* to make a similar tool that lived in a
    webserver and whose default operation was `print`.
    
    > "One of the most interesting aspects [of PHP version 2] included the
    > way `while` loops were implemented. The hand-crafted lexical scanner
    > would go through the script and when it hit the `while` keyword it
    > would remember its position in the file. At the end of the loop, the
    > file pointer sought back to the saved position, and the whole loop was
    > reread and re-executed."
    >
    > — [PHP 5 Power
    > Programming](http://ptgmedia.pearsoncmg.com/images/013147149X/downloads/013147149X_book.pdf)
    > by Andi Gutmans, Stig Sæther Bakken, and Derick Rethans
    
    'Nuff said, I guess.
    
    No, no — you can *never* say enough about PHP!
    
    I would have to say the single greatest [[Software Engineering]]
    achievement of PHP is how it taught us all that
    programming should never be done without having constantly within arm's
    reach a book with a photo of the author's face on it. Preferably on the
    cover, and preferably amidst the [photos of his or her 8
    co-authors](http://www.amazon.com/dp/0470055200/). Even more preferably
    described as a ["Cookbook"](http://www.amazon.com/dp/0672323257/), or a
    collection of ["Hacks"](http://www.amazon.com/dp/0596101392/) — hey, if
    it didn't save me from having to understand what I'm doing, I wouldn't
    have spent the \$30 on it.
    
    However, this is not to diminish the other great advance that PHP has
    brought us. Truly, the shortest path from point A to point B is to slap
    some B-coloured paint onto point A and put up a sign next to it saying
    "Welcome to Point B, Population: You!" And does not PHP help us achieve
    such a software development style — so *effective*, so *powerful*, so
    downright worthy of this maxim?
    
    **Fatal error**: require\_once() [[function.require](function.require)]:
    Failed opening required 'config.php'
    (include\_path='.:/usr/local/share/pear') in
    **/internal/directory/structure/home/website/include/oh\_drat.php** on
    line **444**

Python:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  references:
  - title: Python
    description: Official website of the Python Programming Language
    url: http://www.python.org/
  - title: Python IAQ
    description: Infrequently Answered Questions about Python
    url: http://norvig.com/python-iaq.html
  - title: Jython
    description: Implementation of Python for the JVM
    url: http://www.jython.org/
  as-a-prerequisite: |
    Some or all of the programs in this project are Python scripts, and
    running them requires a Python interpreter, version 2.5.2 or later.
    (Actually it's quite possible older versions of Python will work, but we
    haven't confirmed them.)
    
    While there are several implementations of Python, we're not aware of
    any standards documents defining the language aside from the reference
    implementation and manual produced by the Python project, which we've
    linked to here.
    
    We have also tested our Python scripts on Jython 2.5.1 and found that
    they seem to run quite well on it.
  commentary: |
    Mostly harmless.

R:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://www.r-project.org/'
  as-a-prerequisite: |
    You're on your own, mate.

Ruby:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - http://www.ruby-lang.org/
  as-a-prerequisite: |
      Some or all of the programs in this project are Ruby scripts, and running them
      requires a Ruby interpreter, version 1.8.7 or later.

Scheme: 
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://schemers.org/Documents/Standards/R5RS/'
  - 'http://www.plt-scheme.org/'
  as-a-prerequisite: |
    Any R5RS-conforming Scheme implementation should be able to handle the
    sources for this project. In order to compile a binary with a Scheme
    compiler, you may need to add some driver code.
  description: |
    Scheme is a simple programming language with an extremely regular syntax
    and a [succinct, well-defined
    semantics](http://www.swiss.ai.mit.edu/~jaffer/r5rs_toc.html "Revised^5 Report on the Algorithmic Language Scheme").
  commentary: |    
    Scheme is often looked at historically, and described as a variant of
    LISP. While useful, this historical viewpoint frequently gets in the way
    of thinking about Scheme's significance *today*. In brief, if you are
    evaluating Scheme for your own needs, evaluate *Scheme*, and don't worry
    about LISP or functional programming.
    
    That said, let's go ahead and examine Scheme historically. Its history
    has been one of shedding baggage from its LISP heritage: it has lexical
    (instead of dynamic) scoping, guaranteed (rather than
    if-your-vendor-supports-it) tail-recursive behaviour at execution time,
    hygenic (instead of textual) macros, and continuations as first-class
    objects. These are generally considered significant improvements, and we
    fully agree.
    
    But there's one thing of LISP's that Scheme hasn't shed: its syntax...
    or lack thereof!
    
    Whether you love it or hate it, you have to admit that Scheme's
    S-expression syntax is extremely — no, *pathologically* — regular. Just
    about as orthogonal as syntax can get.
    
    As far as we know, the reason LISP has such a mind-bogglingly minimal
    syntax is that it's a consequence of how it approached higher-order
    functions: *represent functions as lists*. You can already pass lists to
    and return lists from functions, so if functions "are" lists, then
    problem solved, right? And there's no sense having two different
    syntaxes for the same kind of data.
    
    But that didn't turn out too happily, and times have changed. In Scheme,
    function values are *not* lists: they're [closures](closures.html). This
    is overall a nice thing — it avoids the ugliness of trying to determine
    which list is the "right" representation, and allows free variables to
    be captured in function values instead using the crutch of dynamic
    binding.
    
    But that syntax is still there, like some kind of vestigial organ. What
    purpose does it serve now?
    
    Well, the interesting thing about it is that it makes it impossible to
    syntactically distinguish between code and data. Depending on the
    circumstance, this can be a horror or a delight.
    
    Here's the horror: say you're looking at a snippet of a Scheme program.
    You can't tell what `(+ 1 2)` is supposed to be — code, or data? —
    without looking at what context it's in. This can be as confusing as all
    git-out. (And don't get me started on `quasiquote`.)
    
    Here's the delight: it makes it trivial to read and write Scheme
    programs from other Scheme programs. No parsing, no backpatching. No
    blood, sweat, *or* tears. In fact, we wonder why this holdover from LISP
    has not driven Scheme on to become *the* program-analysis language.

# note our fork here somehow
Zz:
  type: Programming Language
  genre: Experimental language
  paradigms:
  - Metalanguage
  computational-class: unknown computational class
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://openzz.cvs.sourceforge.net/*checkout*/openzz/openzz/doc/zzdoc.html'
  - 'http://openzz.sourceforge.net/'
  - 'https://github.com/catseye/OpenZz'
  as-a-prerequisite: |
      The project contains grammars written in the dynamic language of Zz,
      version 2.0.  While Zz was implemented as part of the APE100 parallel computing
      project, the only freely available implementation of Zz that we're aware
      of is OpenZz.
      Our projects have been tested with the OpenZz interpreter version 1.0.4-4.

#----------------------------------------------------------------------------

Ophis Assembler:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors:
  - Michael C. Martin
  links:
  - 'http://hkn.eecs.berkeley.edu/~mcmartin/ophis/'
  - 'https://github.com/michaelcmartin/Ophis'
  description: |
    Ophis is an assembler for the 6502 series of microprocessors.
    Files in the Ophis assembler format often have the file extension `.oph`,
    although files written the Ophis' predecessor, P65, with the `.p65` file extension,
    will generally build with Ophis too.
    You'll need an assembler that conforms to Ophis' syntax in order
    to build executables from these files, and your best bet with that is
    probably the Ophis assembler itself.

NASM Assembler:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://nasm.sourceforge.net/'
  as-a-prerequisite: |
    Some files in this project are x86 (a.k.a IA-32)
    assembly-language sources written in the syntax of the NASM assembler.
    You'll need an assembler that conforms to NASM's syntax,
    version 0.98.39 or later, in order
    to build executables from these files.  Since the only assembler we
    know of that uses NASM's syntax is NASM, and since that's the
    assembler we tested the project with, well, that's the assembler we'll
    recommend that you use here.
    
    Many of these NASM files were converted from older
    assembly-language sources written in the syntax of Turbo Assembler 3.1.
    This is an old-school x86 assembler for DOS, written by Borland.
    In some cases the Turbo Assembler sources are still included in the
    project for historical interest, but the newer NASM sources are what
    the binaries are built from.

Commodore BASIC 2.0:
  # should we consider 2.0 to be just a language version?
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: believed Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Applesoft BASIC:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: believed Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://www.zophar.net/apple2.html'
  description: |
    Programs written in Applesoft BASIC assume that they
    will be running on an Apple ][+, great microcomputer of old.
    Most such software will also run on an Apple //e or similar model.
    Of course, these days, it's more likely you'd be running
    this software on an emulator instead of a museum piece.
  commentary: |
    I've found AppleWin to be a decent Apple emulator on Windows;
    I have yet to find one for *nix that's
    good enough to be my go-to emulator (pun? what pun?).

# for targets of compilers:
x86 machine code:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations:
  - Bochs
  authors: []
  as-a-prerequisite: |
      Programs in this format assume that they will be running on a fairly
      standard x86-based (IA-32) computer architecture, from the 
      lineage that dates back to those old IBM PC's.  Probably a 486
      with a BIOS, keyboard, and basic VGA is the minimum to make
      it worthwhile.  While most modern PC's can handle that reasonably
      well, often a better choice — because it can run under a modern OS,
      rather than actually dedicating the entire computer to it —
      is to run such things under an emulator.  In which case,
      we recommend Bochs.

Bochs:
  type: Language Implementation
  links:
  - 'http://bochs.sourceforge.net/'
  license: LGPL
  host-language: C++
  implementation-type: interpreter

# heh.  for sf2tab:
lookup table:
  type: Programming Language
  genre: Production language
  paradigms:
  - Declarative
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Wireworld:
  type: Programming Language
  # recreational language?
  genre: Experimental language
  paradigms:
  - Cellular automaton
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
