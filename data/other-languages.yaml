# encoding: UTF-8
# actually some of these do have reference distributions
ANSI C:
  type: Programming Language
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    If an implementation is in "ANSI C" we expect you to be able to deal with that.

C99:
  type: Programming Language
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    If an implementation of something here is written in C99,
    that implies you need POSIX to compile it, too.
    But some things here written in C99 can also be compiled as
    ANSI C by defining a symbol -- see the Makefile as appropriate.

Java:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
      If an implementation is in "Java" we expect you to know that:
      requirements:
        build: jdk6 not_required
        run: jre6

Perl:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    We mean Perl 5 here; probably Perl 5.10 is the best version to
    make sure everything runs.

Python:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |-
    Mostly harmless.

Ruby:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Scheme: 
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
      If an implementation is in "Scheme" we expect you to be able to deal with that.

Haskell:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
      If an implementation is in "Haskell" we expect you to be able to deal with that.

Erlang:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
      If an implementation is in "Erlang" we expect you to be able to deal with that.

Lua:
  type: Programming Language
  genre: Production language
  computational-class: shown Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  commentary: |
    We mean Lua 5.0 here.

MSIL:
  type: Programming Language
  genre: Production language
  computational-class: unknown computational class
  has-reference-distribution: false
  implementations: []
  authors: []

Zz:
  type: Programming Language
  genre: Metalanguage
  computational-class: unknown computational class
  has-reference-distribution: false
  implementations: []
  authors: []

Ophis Assembler:
  type: Programming Language
  # "Assembly language"?
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors:
  - Michael C. Martin
  links:
  - 'http://hkn.eecs.berkeley.edu/~mcmartin/ophis/'
  - 'https://github.com/michaelcmartin/Ophis'
  description: |
    Ophis is an assembler for the 6502 series of microprocessors.
    Files in the Ophis assembler format often have the file extension `.oph`,
    although files written the Ophis' predecessor, P65, with the `.p65` file extension,
    will generally build with Ophis too.
    You'll need an assembler that conforms to Ophis' syntax in order
    to build executables from these files, and your best bet with that is
    probably the Ophis assembler itself.

NASM Assembler:
  type: Programming Language
  # "Assembly language"?
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Commodore BASIC 2.0:
  # should we consider 2.0 to be just a language version?
  type: Programming Language
  genre: Production language
  computational-class: believed Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Applesoft BASIC:
  type: Programming Language
  genre: Production language
  computational-class: believed Turing-complete
  has-reference-distribution: false
  implementations: []
  authors: []
  links:
  - 'http://www.zophar.net/apple2.html'
  description: |
    Programs written in Applesoft BASIC assume that they
    will be running on an Apple ][+, great microcomputer of old.
    Most such software will also run on an Apple //e or similar model.
    Of course, these days, it's more likely you'd be running
    this software on an emulator instead of a museum piece.
  commentary: |
    I've found AppleWin to be a decent Apple emulator on Windows;
    I have yet to find one for *nix that's
    good enough to be my go-to emulator (pun? what pun?).


# for targets of compilers:
x86 machine code:
  type: Programming Language
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations:
  - Bochs
  authors: []
  description: |
      Programs in this format assume that they will be running on a fairly
      standard x86-based (IA-32) computer architecture, from the 
      lineage that dates back to those old IBM PC's.  Probably a 486
      with a BIOS, keyboard, and basic VGA is the minimum to make
      it worthwhile.  While most modern PC's can handle that reasonably
      well, often a better choice — because it can run under a modern OS,
      rather than actually dedicating the entire computer to it —
      is to run such things under an emulator.  In which case,
      we recommend Bochs.

Bochs:
  type: Language Implementation
  links:
  - 'http://www.bochs.org/'
  # I think it's BSD, but
  license: Unknown license
  # I think...
  host-language: C99
  implementation-type: interpreter

# heh.  for sf2tab:
lookup table:
  type: Programming Language
  genre: Production language
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []

Wireworld:
  type: Programming Language
  genre: Cellular Automaton
  computational-class: Finite-automata-complete
  has-reference-distribution: false
  implementations: []
  authors: []
