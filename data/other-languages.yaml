# encoding: UTF-8
# actually some of these do have reference distributions
ANSI C:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  generally-compiled: true
  computational-class: Finite-automata-complete
  authors: []
  specification-link: http://clc-wiki.net/wiki/C89
  development-stage: mature
  references: 
  - title: ANSI C docs
    description: Interesting documents about the standardization of C
    url: http://www.lysator.liu.se/c/
  commentary: |
    When an implementation here says it requires ANSI C, it (in theory)
    means that the source files in it conform to C89 (also,
    and more popularly, known as ANSI C.)
    We usually test them with [gcc 3.4](http://gcc.gnu.org/gcc-3.4/),
    but they may work with a gcc version as old as
    [gcc 2.95.3](http://gcc.gnu.org/gcc-2.95/), as well. 
    
    The souce files compile with the `-ansi` flag (and usually `-pedantic`,
    too,) and should (in theory at least) be buildable with any ANSI C
    compiler.
    
    Many of our C projects will compile both as [[C99]] and as
    ANSI C (perhaps omitting some features) by passing the environment
    variable `ANSI=yes` to `make`.
  # not perfectly considered yet. alas.
  references:
  - url: http://gcc.gnu.org/
    title: GCC
    description: The GNU Compiler Collection
  - url: http://www.openwatcom.org/
    title: OpenWatcom
    description: Open-source Watcom C/C++
  - url: http://www.ten15.org/
    title: TenDRA
    description: BSD-licensed, ANDF-based C/C++ compiler
  - url: http://clang.llvm.org/
    title: clang
    description: C language family frontend for LLVM
  - url: http://www.cs.princeton.edu/software/lcc/
    title: lcc
    description: Retargetable compiler for ANSI C
  - url: http://www.desmet-c.com/
    title: DeSmet C
    description: Reasonably sized open-source ANSI C compiler
  - url: http://www.tinycc.org/
    title: TCC
    description: Tiny, fast, LGPL C compiler
  - url: http://www.cpm.z80.de/small_c.html
    title: Small-C
    description: Older, 8-bit portable C-subset compiler
  - url: http://sdcc.sourceforge.net/
    title: SDCC
    description: Small Device C Compiler

BASIC:
  type: Programming Language Family
  # close, but "Beginner language" might be better
  genre: Pedagogical language
  wikipedia: BASIC
  paradigms:
  - Imperative
  authors: []
  development-stage: vintage
  # ehhhh close enough
  specification-link: http://en.wikipedia.org/wiki/BASIC


Borland C:
  type: Programming Language
  genre: Production language
  variant-of: ANSI C
  generally-compiled: true
  no-specification: true
  development-stage: archival
  # Well, Borland.  duh.
  authors: []
  paradigms:
  - Imperative
  description: |
    The dialect of C supported by the [[Borland C++ compiler]] included
    libraries for writing directly to the console, reading directly from the
    keyboard, and so forth.


C99:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  generally-compiled: true
  computational-class: Finite-automata-complete
  authors: []
  specification-link: http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf
  development-stage: mature
  links:
  - http://www.opengroup.org/onlinepubs/9699919799/
  commentary: |
    When an implementation here says it requires C99, it (in theory)
    means that the source files in it conform to the C99 standard.
    These souce files generally are such that they *would* compile with the
    `-ansi` flag *except* that they rely on libraries specified by the Single
    UNIX Specification version 3 (also, and more popularly, known as POSIX)
    to provide access to resources such as clock information and network sockets.
    
    Most modern UNIX-like operating systems implement something
    approximating the POSIX interface. For Windows, compatibility layers
    such as [[Cygwin]] fill this role.
    
    Note that the specification linked to is actually SUSv7, which is very
    similar to SUSv3, but unlike SUSv3 has freely-accessible documentation
    on the web.
    
    Many of our C projects will compile both as C99 and as
    [[ANSI C]] (perhaps omitting some features) by passing the environment
    variable `ANSI=yes` to `make`.

gcc 3.4:
  type: Implementation
  implementation-of:
  - ANSI C
  - C99
  implementation-type: compiler
  host-language: C99
  target-language: native code
  license: GPL
  prebuilt-for-platforms:
  - native code
  links:
  - http://gcc.gnu.org/gcc-3.4/


C++:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  generally-compiled: true
  computational-class: Finite-automata-complete
  authors: []
  standards-body: http://www.open-std.org/jtc1/sc22/wg21/
  development-stage: mature
  references:
  - title: C++ FAQ Lite
    description: Comprehensive compilation of C++ questions and answers
    url: http://www.parashift.com/c++-faq-lite/
  - title: C++ FQA Lite
    description: 'A "Rebuttal" to C++ FAQ Lite: Frequently Questioned Answers'
    url: http://yosefk.com/c++fqa/
  - title: STL
    description: SGI's Standard Template Library Programmer's Guide
    url: http://www.sgi.com/tech/stl/index.html
  - title: Boost
    description: Boost provides free peer-reviewed portable C++ source libraries
    url: http://www.boost.org/
  - title: TFoo::operator=
    description: The Anatomy of the Assignment Operator
    url: http://icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html
  - title: The Dark Side of C++ (PDF)
    description: Slides for a talk about the dark side of C++
    url: http://miek.nl/downloads/2010/c++-talk.pdf
  commentary: |
    For any software project, it's important that you choose the right
    language to develop it in. That's why you'll always choose C++, no
    matter what the project is!
    
    Why will you choose C++? Because it's popular, so a lot of programmers
    know it. And a lot of programmers means a lot of competition, and that
    means you'll be able to hire programmers at the lowest rate! This will
    surely offset whatever costs might be incurred from choosing an
    ill-suited programming language and hiring programmers who work at the
    lowest rate.
    
    And why *is* C++ such a popular programming language?
    
    Is it because it's a good programming language? Hardly. That's like
    saying that coffee is a popular beverage because it's healthful.
    
    No, C++ is popular because C++ is popular. Hey, Google is a big,
    successful company, and I hear they use C++... it must be *why* they're
    successful! You should use C++ too!
    
    But that's not the only reason. C++ is popular because programmers
    *like* it. I suppose the question then is, *why* do programmers like it?
    
    Is it because C++ makes it easy to write correct, maintainable code? Is
    it because C++ is easy to learn? Is it because there are things you can
    do in C++ that you can't do in any other language? Is it that C++ lets
    your programs run as fast as they possibly can?
    
    Anyone who has ever used C++ can tell you the answer to all of those
    questions: No. (No, not even when it comes to making your program run as
    fast as it can. C++ allows so much control over the low-level workings
    of the program that the compiler cannot make optimizations that it
    otherwise could, if the programmer were constrained to working at a
    higher level of abstraction.)
    
    So what is it about C++ that makes programmers like it?
    
    Well, I have a theory. While most "normal" people feel that their lives
    are too complicated, too full of arbitrary rules and boring details and
    essentially meaningless things to remember, there's a certain strain of
    psychology that actually *thrives* on complexity like this, because such
    complexity *generates gratuitous expertise*.
    
    What I mean by this is that if a system is easy to master, then there's
    no opportunity to show off your mastery of it. There's no way to display
    your dominance through your command of minutiae and knowledge of trivia.
    And if that's what really motivates you, then, well, you're going to
    avoid that system, because it doesn't provide you anything to work with
    in the social game you want to play. Instead, you'll look for something
    with a lot of nooks and crannies and bells and whistles and jargon and
    buzzwords that you can familiarize yourself with, and you'll take every
    opportunity to demonstrate that you are More Familiar with It than Thou.
    You'll look for something like... well, like C++.
    
    And if it so happens that programmers with this general personality type
    *also* like the idea of *total control over their program* — and while
    I'm no expert on psychology, somehow that seems likely — C++'ll have'em
    downright hooked.


CSS:
  type: Programming Language
  genre: Production language
  paradigms:
  - Declarative
  computational-class: unknown computational class
  specification-link: http://www.w3.org/TR/CSS2/
  # only because "what is this i don't even" isn't a development stage
  development-stage: mature
  authors: []
  commentary: |
    If I, as a programmer, were to tell you that CSS is the ultimate hacking
    language, would you be surprised? After all, it's not even a
    [[Programming Language|programming language]], really. But that doesn't really
    matter, does it? It meets the only possible criterion there could be for
    the ultimate hacking language: in order to achieve the effect that what
    you want, you have to hack and hack and hack...
    
    So, I have a question. If CSS is so superior to [those awful tables
    which should never ever be used for
    layout](http://phrogz.net/CSS/HowToDevelopWithCSS.html#tables), how come
    a simple and much desired three-column layout, so trivial to construct
    with a table, is considered [one of the holy grails of
    CSS](http://www.alistapart.com/articles/holygrail)?
    
    Seems that the real solution to this would be to have some set of
    elements that has the layout behaviour of tables but without the "treat
    this as tabular data, would you please" semantics. I suppose that's what
    `display: table-cell` *et al* is for — if only more browsers supported
    it.
    
    I kvetch, but there *is* one very nice thing about CSS: unlike
    [[Javascript]], it's declarative, and nowhere near
    [[Universality|as powerful as a Turing machine]].  So, it might make
    your page look ugly in nine out of ten browsers six out of seven days of
    the week, but at least it probably won't hang, or crash, or corrupt the
    browser's state.
  references:
  - title: Assorted CSS samples on Phrogz.net
    description: Useful and insightful CSS articles
    url: http://phrogz.net/CSS/
  - title: css Zen Garden
    description: Demonstrates what can be accomplished visually with CSS
    url: http://www.csszengarden.com/
  - title: CSS Techniques
    description: CSS Techniques I Wish I Knew When I Started Designing Websites
    url: http://www.noupe.com/css/css-techniques-i-wish-i-knew-when-i-started-designing-websites.html


Erlang:
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  # just, not to native code
  generally-compiled: true
  computational-class: Turing-complete
  standards-body: http://www.erlang.org/
  development-stage: mature
  authors: []
  references:
  - title: Open Source Erlang/OTP
    description: Ericsson's official distribution site
    url: http://www.erlang.org/
  commentary: |
    Note that compiled Erlang modules are `.beam` files in the `ebin`
    directory. The source code lives in the `src` directory, and an Erlang
    compiler (such as the one which ships with Erlang/OTP) is required to
    build the modules.
    
    Also note that the `.beam` files will have to be recompiled in order to
    run under recent versions (e.g. R13B) of Erlang/OTP, as the
    binary format has changed.
    
    Also note there is a good chance that the sources will compile and run
    on an older version (say, R9C) of Erlang/OTP, but you may need
    to make some manual changes and system setup.

Erlang/OTP R13B:
  type: Implementation
  reference: true
  implementation-of:
  - Erlang
  # well, it builds beam files, but
  implementation-type: interpreter
  host-language: C99
  license: Erlang Public License
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.erlang.org/


# should probably call this Haskell 98
Haskell:
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  - Lazy
  computational-class: Turing-complete
  standards-body: http://www.haskell.org/
  development-stage: mature
  authors: []
  references:
  - url: http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
    title: Tour of Haskell Syntax
    description: Informal overview of the syntax of Haskell
  - url: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
    title: A Haskell regular expression tutorial
    description: A Haskell regular expression tutorial
  - url: http://sequence.complete.org/node/258
    title: A simple TCP server
    description: Short tutorial for network programming in Haskell
  description: |
    Haskell is a pure functional language with lazy evaluation.
  commentary: |
    In theory, Haskell is the perfect language for writing reference
    implementations of programming languages.  It, itself, has semantics
    which are specified reasonably formally.  It's purely functional
    (does not permit side-effects), and these two things bring it much
    closer to being like mathematics than other languages.
    Additionally, Haskell programs are lazily evaluated (expressions
    are only evaluated if they are needed), so, basically, Haskell is
    denotational semantics.  Except it's also a program, so you can
    run it.  It's executable denotational semantics.
    
    Pretty sweet, right?  Well... yes, except for the small fact that
    denotational semantics may not be the best way to describe your language
    in the first place.  You might have to describe I/O and concurrency,
    for example, and denotational semantics doesn't make that easy.
    
    But I hear you say, well, Haskell has I/O and concurrency features.
    
    OK, look.  It's a pretty profound thing to show that you can encode I/O
    or concurrency or really, any feature of an imperative language that you
    want, into a lazy functional language using monads, *but*, that doesn't
    necessarily mean that it's always a beautiful thing to actually *do* so.
    
    Yes you can do it, but no, it's not one of Haskell's strengths.  I've
    accepted that.
    
    Using Haskell for other purposes, though?  Well, I've already accepted
    that, when going outside the "batch processing" world, Haskell is a little
    out of its element, so I would not jump at the opportunity.
    Armchair category theorists might enjoy writing a multithreaded
    webserver with shared transactional memory monads or whatever, but I
    have trouble imagining anyone except a category theorist enjoying
    maintaining such a beast, so I wouldn't recommend it for most
    "operational" projects.  Choose carefully.
    
    Maybe functional reactive programming, or other techniques, will
    change this.  Or maybe Haskell will simply continue to be the academic
    playground for type theory research.  Or maybe both.

ghc:
  type: Implementation
  implementation-of:
  - Haskell
  implementation-type: compiler
  host-language: Haskell
  target-language: native code
  license: BSD license
  generally-recommended: true
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.haskell.org/ghc/

hugs:
  type: Implementation
  implementation-of:
  - Haskell
  implementation-type: interpreter
  host-language: C99
  # http://cvs.haskell.org/Hugs/pages/users_guide/license.html
  license: BSD license
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.haskell.org/hugs/


Java:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  # just, not to native code
  generally-compiled: true
  computational-class: Turing-complete
  standards-body: http://www.oracle.com/technetwork/java/index.html
  development-stage: mature
  authors: []
  references:
  - title: Oracle Technology Network > Java
    description: Official website of the Java™ Platform
    url: http://www.oracle.com/technetwork/java/index.html
  - title: Java Specs
    description: The Java™ Virtual Machine and Language Specifications
    url: http://docs.oracle.com/javase/specs/

Java SE 6 JDK 1.6.0:
  type: Implementation
  reference: true
  implementation-of:
  - Java
  # well, it builds class files, but
  implementation-type: interpreter
  host-language: Unknown language
  # it's actually the "Oracle Binary Code License Agreement for Java SE"
  license: Unknown license
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.oracle.com/technetwork/java/javase/downloads/jdk7u7-downloads-1836413.html
  commentary: |
    Because most of our distributions which include a Java implementation also
    include prebuilt `.class` files, all you really need to run them is the
    Java SE 6 JRE 1.6.0 from Oracle.  But we suggest installing the JDK, in case
    you want to rebuild the `.class` files.


Javascript:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: Turing-complete
  specification-link: http://www.ecma-international.org/publications/standards/Ecma-262.htm
  development-stage: mature
  authors: []
  description: |
    Javascript (also and more properly known as ECMAScript) is a
    [[Programming Language|programming language]] that is implemented
    primarily in web browsers
    in order to let scripts control the dynamic behaviour of a web page,
    such as what happens when the user clicks on some region of text.
  commentary: |
    Javascript, now there's a programming language rags-to-riches story.
    Well, it still wears rags, but you know what I mean.
    
    In the beginning, the World Wide Web was just a bunch of interlinked
    static documents, which was just fine.  Hypertext, they called it.  Then
    immediately it grew fill-out forms and queries which were sent to web
    servers, which could respond with dynamically-generated content, like
    the results of a web search, which was great.
    
    And then along the way, the Web succumbed to the inviolable
    law of [[Software Engineering|software engineering]] that states
    "Any sufficiently complex
    program contains a buggy, half-implemented, undocumented
    version of [[Lisp]]".  If you've ever been on the receiving side of
    requirements, you might also know this as, "Can we add a scripting
    language?  That'd be awesome."  (Because taking a nice, predictable
    system and making it [[Turing-complete]] is [[Esolang|always awesome]].)
    
    So, even though web pages at the time hardly justified being scripted,
    Javascript was born.  And, to be fair, it's really not such a bad language
    for having been designed in two weeks.  Of course, the name was pure
    marketing; it shares almost nothing with [[Java]] except curly braces.
    
    And so the Web went through a painful period where Javascript
    was used to make sites that tried to stand out from the crowd by
    annoying the user in more advanced and petulant and irritating ways.
    And during Javascript's childhood, every vendor implemented it
    slightly differently, with different bugs and different reckonings of
    the DOM (the API that refers to the parts of a web page).
    
    And then, Ajax happened, which meant, in essence, that, you
    could now use Javascript and [[XML]] to reload part of a page without
    reloading the whole thing.  Which meant, in essence, that web pages
    started to look a lot more like traditional user interfaces.  Which meant,
    in essence, that there was actually a (somewhat) justifiable reason for
    using Javascript.
    
    And then a standard was written for Javascript (sort of) and jQuery
    was developed (which handled some of the discrepancies between
    browsers for you) and JSON took over from XML (but we
    still call it Ajax, not Ajaj) and vendors' Javascript implementations
    started to do JIT compiling and got reasonably performant and some
    clever wag coined the term "web app" and *at that very moment* it
    became an acceptable fact of life for a web page to hang or crash.
    (Because it's now an "app", you see.)
    
    And then it got even weirder.  Developers decided they wanted to
    run Javascript *outside* of the browser.  Which, for the purposes of
    automated testing of the scripts used on web pages, makes some sense.
    But *then* some exceedingly clever people decided
    it should [run on servers](http://nodejs.org/) and that
    new, back-end software should be developed in it.  And the next
    thing you know, it has an
    [ncurses library](https://github.com/mscdex/node-ncurses).  I give up.
    
    Our policy regarding Javascript on [[catseye.tc]] is as follows:
    
    *   *If you don't like it, turn it off.*
        
        Unless it's one of the fancy pages that actually requires
        Javascript for some [[HTML5]] craziness, like running an
        [[Esolang]] in the browser, the page should
        gracefully degrade when there's no Javascript.
        (The site is even decently readable and navigable without
        styling. So if you don't like our far-out background graphics,
        or you want the genuine experience of surfing the web circa
        1996, try turning off [[CSS]] too.)
        
    *   *Use commodity components.*
        
        There's still too much variation between different browsers
        that whenever we can use a third-party Javascript library such
        as jQuery that's been battle-tested on different browsers, we
        probably should.  There's an argument that jQuery is large and
        bloated, but really, it's not *that* bad, and since we grab it from
        a CDN there's a good chance the user's browser already has it
        cached.
    
    *   *Keep it simple.*
        
        Of course, the availability of many high-quality, battle-tested
        Javascript libraries is a bit of a double-edged sword; there is the
        temptation to use every library and plugin under the sun in a
        vain attempt to make the user's web experience totally *bitchen*,
        man.  But one cannot underestimate the number of things that
        can go wrong, and that by Murphy's law, will.  For example,
        clever proxies used by 4G providers which concatenate and
        compress the Javascript used on a page and include it inline.
        (Did you just assume that that Javascript file you externally
        referenced really was external?  Oops.)
        
  references:
  - url: http://www.quirksmode.org/js/contents.html
    title: JavaScript at quirksmode
    description: Nice, large set of JS documents, examples, explanations
  - url: http://onlinetools.org/articles/unobtrusivejavascript/
    title: Unobtrustive JavaScript
    description: Seperation of concerns between Javascript, CSS, &amp; HTML
  - url: http://betterexplained.com/articles/speed-up-your-javascript-load-time/
    title: Speed Up Your Javascript Load Time
    description: Assorted useful tips for, uh, speeding up Javascript load time

Firefox:
  type: Implementation
  reference: false
  implementation-of:
  - Javascript
  implementation-type: interpreter
  host-language: C++
  license: MPL 2.0
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.mozilla.org/
  commentary: |
    Yes, I know Firefox is more than just an implementation of Javascript,
    and Javascript is actually implemented by the mumbleMonkey engine
    *inside* Firefox.
    But it's useful to have something to recommend to you to use, when
    we have something that's written in Javascript, like [[yoob.js]] or
    the output of the [[ALPACA]] compiler.


Lisp: 
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  - Imperative
  computational-class: Turing-complete
  specification-link: http://www.lispworks.com/documentation/HyperSpec/Front/index.htm
  development-stage: mature
  authors: []
  description: |
    Lisp is a programming language.
  commentary: |
    I'm one of those people who wonders why anyone bothers programming in,
    talking about, or thinking about Lisp anymore, since [[Scheme]] exists.
    That's just me, though.


Lua:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: Turing-complete
  standards-body: http://www.lua.org/
  development-stage: mature
  authors: []
  references:
  - title: Lua
    description: Official Lua website
    url: http://www.lua.org/

lua 5.0.3:
  type: Implementation
  reference: true
  implementation-of:
  - Lua
  implementation-type: interpreter
  host-language: C99
  license: MIT license
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.lua.org/versions.html#5.0
  commentary: |
    Note that
    the 5.1.x series of Lua is not generally compatible with the 5.0.x
    series.

MSIL:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  generally-compiled: true
  computational-class: unknown computational class
  specification-link: http://www.ecma-international.org/publications/standards/Ecma-335.htm
  development-stage: mature
  authors: []

ilasm:
  type: Implementation
  implementation-of:
  - MSIL
  implementation-type: compiler
  host-language: Unknown language
  target-language: .NET executable
  prebuilt-for-platforms:
  - native code
  license: Unknown license


Perl:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: Turing-complete
  standards-body: http://www.perl.org/
  development-stage: mature
  authors: []
  commentary: |
    Perl is what happens when you play [[Katamari Damacy]]
    with the Unix toolchain.
    
    Ah, but the world should thank Perl for being the experiment that
    demonstrated the effect of [designing a programming language around
    natural-language principles](http://www.wall.org/~larry/natural.html)
    (because for some reason, we learned so little from COBOL.) And of
    course we should thank the experimenters for being so candid and
    unbiased about their results. Finally, we have data that shows us what
    we already knew, namely that [programming, no, "scripting" is really a
    fuzzy endeavour](http://www.perl.com/pub/a/2007/12/06/soto-11.html) —
    much like talking, or thinking. This is why Perl scripts, and by
    extension all computer programs, have so few bugs.
    
    But if you can psychologically overcome all of that — perhaps with the
    aid of some sort of nuclear-powered ninja weaponry — Perl's not *that*
    bad. Unlike [[C++]], it has garbage collection. It has
    anonymous [[Closure|function closures]] (unlike [[PHP]],)
    and they can consist of more than one expression (unlike [[Python]].) And
    things like `use strict` at least smell like an attempt to approach some
    sort of trying to permit, I don't know, enforcing discipline, or
    something, if you think that would help.

perl 5.8.8:
  type: Implementation
  reference: true
  implementation-of:
  - Perl
  implementation-type: interpreter
  host-language: C99
  prebuilt-for-platforms:
  - native code
  license: Artistic License


PHP:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Object-oriented
  computational-class: Turing-complete
  standards-body: http://www.php.net/
  development-stage: mature
  authors: []
  commentary: |
    PHP is language defined by a tool built by some guys who saw a
    [[Perl]] interpreter once and thought it was really neat. They
    thought that it would just *rock* to make a similar tool that lived in a
    webserver and whose default operation was `print`.
    
    > "One of the most interesting aspects [of PHP version 2] included the
    > way `while` loops were implemented. The hand-crafted lexical scanner
    > would go through the script and when it hit the `while` keyword it
    > would remember its position in the file. At the end of the loop, the
    > file pointer sought back to the saved position, and the whole loop was
    > reread and re-executed."
    >
    > — [PHP 5 Power
    > Programming](http://ptgmedia.pearsoncmg.com/images/013147149X/downloads/013147149X_book.pdf)
    > by Andi Gutmans, Stig Sæther Bakken, and Derick Rethans
    
    'Nuff said, I guess.
    
    No, no — you can *never* say enough about PHP!
    
    I would have to say the single greatest [[Software Engineering|software engineering]]
    achievement of PHP is how it taught us all that
    programming should never be done without having constantly within arm's
    reach a book with a photo of the author's face on it. Preferably on the
    cover, and preferably amidst the [photos of his or her 8
    co-authors](http://www.amazon.com/dp/0470055200/). Even more preferably
    described as a ["Cookbook"](http://www.amazon.com/dp/0672323257/), or a
    collection of ["Hacks"](http://www.amazon.com/dp/0596101392/) — hey, if
    it didn't save me from having to understand what I'm doing, I wouldn't
    have spent the \$30 on it.
    
    However, this is not to diminish the other great advance that PHP has
    brought us. Truly, the shortest path from point A to point B is to slap
    some B-coloured paint onto point A and put up a sign next to it saying
    "Welcome to Point B, Population: You!" And does not PHP help us achieve
    such a software development style — so *effective*, so *powerful*, so
    downright worthy of this maxim?
    
    **Fatal error**: require\_once() [[function.require](function.require)]:
    Failed opening required 'config.php'
    (include\_path='.:/usr/local/share/pear') in
    **/internal/directory/structure/home/website/include/oh\_drat.php** on
    line **444**


Plankalkül:
  type: Programming Language
  genre: Experimental language
  paradigms:
  - Imperative
  - 2-dimensional
  # I really don't know
  computational-class: unknown computational class
  no-specification: true
  authors:
  - Konrad Zuse
  development-stage: vintage
  links:
  - 'http://catseye.tc/gallery/languages/plankalkuel/'
  description: |
    Plankalkül was probably the very first attempt at a formalized notation for
    computer programs, and is considered by many to be the first programming language.
    The linked article describing the language, transliterated to HTML
    from scans provided by the Retrocomputing Museum, originally appeared in
    Communications of the ACM, July 1972, Volume 15, Number 7.
  commentary: |
    Actually I'm sure there's a quite good specification somewhere out
    there nowadays.


Python:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: Turing-complete
  standards-body: http://www.python.org/
  development-stage: mature
  authors: []
  references:
  - title: Python
    description: Official website of the Python Programming Language
    url: http://www.python.org/
  - title: Python IAQ
    description: Infrequently Answered Questions about Python
    url: http://norvig.com/python-iaq.html
  commentary: |
    Mostly harmless.
    
    Hah, I say that and it makes it sound like I *like* Python.  That can't
    be right.  All languages are crap.  I'm a language designer — why else
    would I be a language designer if it were not for the fact that all
    languages are crap?
    
    But I am weary.  I urge you to consider that Python may be pretty on
    the surface, but go on, scratch that surface.  See what you find.  Tell
    me if it's pretty.  Go on, do it.
    
    Here, I'll get you started.
    
        >>> a = 200
        >>> b = 200
        >>> c = 300
        >>> d = 300
        >>> a is b
        True
        >>> c is d
        False
        >>> 300 is 300
        True
    
    But wait, there's more!
    
        >>> True = 4
        >>> True
        4
        >>> 4 == True
        True

cPython 2.6.7:
  type: Implementation
  reference: true
  implementation-of:
  - Python
  implementation-type: interpreter
  host-language: C99
  license: Unknown license
  prebuilt-for-platforms:
  - native code
  generally-recommended: true
  links:
  - http://docs.python.org/license.html

Jython 2.5.1:
  type: Implementation
  summary: Implementation of Python for the JVM
  reference: false
  implementation-of:
  - Python
  implementation-type: interpreter
  host-language: Java
  license: Unknown license
  links:
  - http://www.jython.org/
  - http://www.jython.org/license.html


R:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  computational-class: Turing-complete
  standards-body: http://www.r-project.org/
  # only because there's no development stage "THE FUTURE"
  development-stage: mature
  authors: []
  isbn: 3-900051-07-0
  commentary: |
    [R IS THE LANGUAGE OF THE FUTURE](http://www.inside-r.org/blogs/2011/03/31/revolutions-chief-scientist-r-language-future).
    
    IT'S SO FUTURE, IT EVEN HAS AN ISBN: 3-900051-07-0

R 2.13.1:
  type: Implementation
  implementation-of:
  - R
  implementation-type: interpreter
  host-language: Unknown language
  license: GPL
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.r-project.org/


Ruby:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Functional
  - Object-oriented
  computational-class: Turing-complete
  standards-body: http://www.ruby-lang.org/
  development-stage: mature
  authors: []
  references:
  - url: http://www.fincher.org/tips/Languages/Ruby/
    title: Ruby Tutorial
    description: Ruby Tutorial with Code Samples

ruby 1.8.7:
  type: Implementation
  reference: true
  implementation-of:
  - Ruby
  implementation-type: interpreter
  host-language: C99
  license: BSD license
  prebuilt-for-platforms:
  - native code
  links:
  - http://www.ruby-lang.org/en/downloads/
    http://www.ruby-lang.org/en/about/license.txt


Rust:
  type: Programming Language
  genre: Production language
  # not really OO, more like algebraic type classes; should add that?
  paradigms:
  - Imperative
  computational-class: Turing-complete
  standards-body: http://www.rust-lang.org/
  development-stage: work in progress
  authors: []

rust (Rust):
  type: Implementation
  reference: true
  implementation-of:
  - Rust
  implementation-type: compiler
  host-language: Rust
  target-language: native code
  license: Unknown license
  prebuilt-for-platforms:
  - native code


# should call this R5RS Scheme
Scheme: 
  type: Programming Language
  genre: Production language
  paradigms:
  - Functional
  computational-class: Turing-complete
  specification-link: http://schemers.org/Documents/Standards/R5RS/
  development-stage: mature
  authors: []
  description: |
    Scheme is a simple programming language with an extremely regular syntax
    and a succinct, well-defined semantics.
  commentary: |    
    Scheme is often looked at historically, and described as a variant of
    [[Lisp]]. While useful, this historical viewpoint frequently gets in the way
    of thinking about Scheme's significance *today*. In brief, if you are
    evaluating Scheme for your own needs, evaluate *Scheme*, and don't worry
    about Lisp or functional programming.
    
    That said, let's go ahead and examine Scheme historically. Its history
    has been one of shedding baggage from its Lisp heritage: it has lexical
    (instead of dynamic) scoping, guaranteed (rather than
    if-your-vendor-supports-it) tail-recursive behaviour at execution time,
    hygenic (instead of textual) macros, and continuations as first-class
    objects. These are generally considered significant improvements, and we
    fully agree.
    
    But there's one thing of Lisp's that Scheme hasn't shed: its syntax...
    or lack thereof!
    
    Whether you love it or hate it, you have to admit that Scheme's
    S-expression syntax is extremely — no, *pathologically* — regular. Just
    about as orthogonal as syntax can get.
    
    As far as we know, the reason Lisp has such a mind-bogglingly minimal
    syntax is that it's a consequence of how it approached higher-order
    functions: *represent functions as lists*. You can already pass lists to
    and return lists from functions, so if functions "are" lists, then
    problem solved, right? And there's no sense having two different
    syntaxes for the same kind of data.
    
    But that didn't turn out too happily, and times have changed. In Scheme,
    function values are *not* lists: they're [[Closure|closures]]. This
    is overall a nice thing — it avoids the ugliness of trying to determine
    which list is the "right" representation, and allows free variables to
    be captured in function values instead using the crutch of dynamic
    binding.
    
    But that syntax is still there, like some kind of vestigial organ. What
    purpose does it serve now?
    
    Well, the interesting thing about it is that it makes it impossible to
    syntactically distinguish between code and data. Depending on the
    circumstance, this can be a horror or a delight.
    
    Here's the horror: say you're looking at a snippet of a Scheme program.
    You can't tell what `(+ 1 2)` is supposed to be — code, or data? —
    without looking at what context it's in. This can be as confusing as all
    git-out. (And don't get me started on `quasiquote`.)
    
    Here's the delight: it makes it trivial to read and write Scheme
    programs from other Scheme programs. No parsing, no backpatching. No
    blood, sweat, *or* tears. In fact, we wonder why this holdover from Lisp
    has not driven Scheme on to become *the* program-analysis language.

plt-r5rs:
  type: Implementation
  implementation-of:
  - Scheme
  implementation-type: interpreter
  host-language: C99
  license: LGPL
  generally-recommended: true
  prebuilt-for-platforms:
  - native code
  links:
  - http://racket-lang.org/


SETL: 
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  computational-class: Turing-complete
  specification-link: http://setl.org/setl/doc/
  # archival?
  development-stage: mature
  authors: []


Visual Basic:
  type: Programming Language
  genre: Production language
  member-of: BASIC
  standards-body: http://microsoft.com/
  development-stage: mature
  paradigms:
  - Imperative
  authors: []


XML: 
  # sigh
  type: Programming Language
  genre: Production language
  paradigms:
  - Declarative
  computational-class: Finite-automata-complete
  specification-link: http://www.w3.org/TR/REC-xml/
  development-stage: mature
  authors: []


Zz:
  type: Programming Language
  genre: Experimental language
  paradigms:
  - Metalanguage
  computational-class: unknown computational class
  specification-link: http://openzz.cvs.sourceforge.net/*checkout*/openzz/openzz/doc/zzdoc.html
  # abandoned?
  development-stage: mature
  authors: []
  links:
  - 'http://openzz.sourceforge.net/'
  commentary: |
    It's real cool and all but there are definitely things I would have
    done differently.  See the [[Zzrk]] documentation for some of my
    observations.


#----------------------------------------------------------------------------
# low-level things
#----------------------------------------------------------------------------

Ophis Assembler:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  generally-compiled: true
  computational-class: Finite-automata-complete
  development-stage: mature
  authors:
  - Michael C. Martin
  links:
  - 'http://hkn.eecs.berkeley.edu/~mcmartin/ophis/'
  - 'https://github.com/michaelcmartin/Ophis'
  description: |
    Ophis is an assembler for the 6502 series of microprocessors.
    Files in the Ophis assembler format often have the file extension `.oph`,
    although files written the Ophis' predecessor, P65, with the `.p65` file extension,
    will generally build with Ophis too.
    You'll need an assembler that conforms to Ophis' syntax in order
    to build executables from these files, and your best bet with that is
    probably the Ophis assembler itself.

Ophis Assembler distribution:
  type: Distribution
  github: michaelcmartin/Ophis

Ophis:
  type: Implementation
  implementation-of:
  - Ophis Assembler
  implementation-type: compiler
  reference: true
  license: MIT license
  host-language: Python
  target-language: 6502 machine code
  in-distribution: Ophis Assembler distribution


NASM Assembler:
  type: Programming Language
  genre: Production language
  paradigms:
  - Imperative
  - Assembly
  generally-compiled: true
  computational-class: Finite-automata-complete
  standards-body: http://nasm.us/
  development-stage: mature
  authors: []
  commentary: |
    In our projects, many of these NASM files were converted from older
    assembly-language sources written in the syntax of Turbo Assembler 3.1.
    This is an old-school x86 assembler for [[MS-DOS]], written by Borland.
    In some cases the Turbo Assembler sources are still included in the
    project for historical interest, but the newer NASM sources are what
    the binaries should be built from.

NASM:
  type: Implementation
  implementation-of:
  - NASM Assembler
  implementation-type: compiler
  reference: true
  license: MIT license
  host-language: C99
  target-language: x86 machine code
  in-distribution: NASM Assembler distribution

NASM Assembler distribution:
  type: Distribution
  reference: true
  links:
  - http://www.nasm.us/


# heh.  for sf2tab:
lookup table:
  type: Programming Language
  genre: Pedagogical language
  paradigms:
  - Declarative
  computational-class: Finite-automata-complete
  # it's, uh.  pretty self-explanatory, actually.
  no-specification: true
  development-stage: mature
  authors: []


Wireworld:
  type: Programming Language
  # recreational language?
  genre: Experimental language
  paradigms:
  - Cellular automaton
  computational-class: Finite-automata-complete
  # i'll look it up someday
  no-specification: true
  development-stage: mature
  authors: []


.NET executable:
  type: Programming Language
  # albeit virtual
  genre: Machine language
  paradigms: []
  no-specification: true
  development-stage: mature
  authors: []
  references:
  - url: http://www.msdn.microsoft.com/netframework/
    title: MSDN .NET
    description: Microsoft .NET Developer Center
  - url: http://plas.fit.qut.edu.au/gpcp/
    title: GPCP
    description: Gardens Point Component Pascal


#----------------------------------------------------------------------------
# miscellany!
#----------------------------------------------------------------------------

Unknown language:
  type: Programming Language
  genre: Production language
  paradigms: []
  no-specification: true
  # yes, the unknown language has been in widespread use for a while now
  development-stage: mature
  authors: []
  description: |
    This node represents the fact that I don't know what language some
    implementation was written in.
