# encoding: UTF-8
Software Engineering:
  type: Discipline
  commentary: |
    Software engineering is the act of coordinating software workers
    (designers, developers, testers, etc.) for the purpose of producing and
    maintaining software.
    
    The central problem of software engineering is thus:
    
    -   The best way to develop the implementation of a software module is
        by frequent incremental changes.
    -   The *worst* way to develop the *interfaces between software modules*
        is by frequent incremental changes.
    
    These two things are often referred to as "programming in the small" and
    "programming in the large", although size really has nothing to do with
    it — it's all about the number of cross-references.
    
    There are, of course, other problems of software engineering, but they
    all tend to relate to the central problem.
    
    That said, here is [[Cat's Eye Technologies]] official position on
    software engineering:
    
    **Don't.**
    
    Obviously we don't mean that. Or do we?
    
    There are two schools of thought about how to maintain systems that are
    "larger" (read: have more cross-references) than a single person, or a
    single team, can fully comprehend. Most modern software falls into this
    category.
    
    One is to throw resources at it, on the model of evolutionary growth, or
    trial and error: look for things that look promising to change (perhaps
    because it looks like others changed them when trying to do something
    similar,) change them, and once it does more or less what you want, hope
    nothing else has been broken and **for God's sake don't touch it
    again!!**
    
    The other is to try to *understand* the system, possibly by reducing it
    into smaller systems that are easier to understand while codifying and
    documenting the interfaces between the systems.
    
    If the first is the approach embodied by mainstream software engineering
    — and I'd like to *believe* it isn't but from what I've seen *it is* —
    then no. We don't want any part of that. Nondeterministic behaviour from
    a `Makefile`? We want to know *why*. It's not enough to throw in targets
    and dependencies (and perhaps even pauses) so that it doesn't *usually*
    happen. Yes, you can get back to work on your "real" project that way,
    but you're digging a huge hole for yourself in the long view — you're
    not solving the underlying problem *and* you're increasing the
    complexity of the system.
    
    You might say we belong to the [Edsger Dijkstra school of software
    engineering](http://www.cs.utexas.edu/~EWD/transcriptions/EWD13xx/EWD1305.html "Answers to questions from students of Software Engineering").
    ([Education, too](cs-education.html "About CS Education").)


Release Engineering:
  type: Discipline
  description: |
    Historically, Cat's Eye Technologies has usually identified each release
    of a software distribution with only a release number. The release number is
    really just the date that the software was released, formatted as
    `YYYY.MMDD`. Each of `Y`, `M`, and `D` is a single digit, so that it
    sorts nicely, even in a purely lexicographical sort order. In
    retrospect, `YYYY.MM.DD` might have been a more structurally consistent
    choice, but it's not as nicely symmetrical.
    
    Using only the release date to identify releases mostly suffices for
    distributions like ours, which rarely have any maintenance needs warranting
    branches and such. But most of our distributions do contain implementations of
    [[Programming Language|programming languages]],
    and these languages may or may not change
    between releases. For example, if we're just fixing bugs in a feature of
    the implementation, or clarifying the documentation or whatever, that's
    not a change to the language. But if all we use to identify it is a
    release number, you can't tell if it's a change to the language or not.
    
    In addition, some of our distributions used a different convention, usually
    two numbers `A.B` which resembled a fraction in decimal notation: often
    `B` would be two digits (like 94) which did not count the number of
    minor releases since the last major release cycle, but rather tried to
    measure "how close" it was to the *next* major release cycle. Version
    numbers like this were sometimes also followed by an (essentially
    meaningless) letter.
    
    Realizing what a mess this is, we have strived to revise our release
    identification system, as well as to make it more consistent.
    
    With few exceptions, every distribution now carries both a version and a
    revision. The version consists of a major version number and a minor
    version number, in the format `A.B`, where `A` and `B` are both
    non-negative integers. The revision is the same as the old release
    number, that is, it is the date in `YYYY.MMDD` format. The version and
    revision are separated by hyphens, so a new-style "distfile" name
    typically looks like `foo-1.3-2009.0116.zip` (although we are by and
    large still providing only the legacy distfiles for download).
    
    The rules for when these numbers change are as follows:
    
    -   If a new release of a distribution supports the same interface
        (syntax and semantics, API, protocol, or what have you) as the
        previous release of that distribution, then the version
        will be the same as the old distribution, but the revision will be
        different.
    -   If a new release of a distribution is more-or-less backwards-compatible
        with the previous release, then the major version will be the same,
        but the minor version and revision will be different.
    -   If a new release of a distribution is distinctly *not*
        backwards-compatible with the previous release, then the major
        version will be different, the minor version is typically reset to
        zero, and the revision will of course be the date of the release.


Distribution Organization:
  type: Discipline
  description: |
    This is a rough guide to how [[Cat's Eye Technologies]]'
    [[Distribution|distributions]] are laid out.  It is prescriptive,
    specifying how distributions should be laid out, but it is informed by
    the general pattern we're trying to find in our distributions.  This
    guide is currently a work in progress and should not be considered
    complete yet.
    
    Certain files in a distribution's root directory have standard meanings:
        
    -   `README.markdown` (preferred) or `README` or `README.txt`
        
        A short text (or preferably Markdown) document summarizing what the
        distribution is a distribution of, what sorts of files it contains,
        where to get the latest version of the distribution, and what other
        tools might be needed to use (run or build) the files found in it.
        
        READMEs for [[Esolang|esolangs]] may describe the entire language.
        I'm not sure if this is a good practice or not.
        It started because Bitbucket would only HTMLify
        a Markdown file in its source viewer if it was the README, but now
        it will do that for every Markdown file, so there is less reason to
        put the whole language description here.  Still, for some esolangs,
        this style seems to fit.  (The only problem is that there isn't
        usually a good place to give the other info, like how to build and
        run the included implementations.)
        
    -   `LICENSE` or `UNLICENSE`
        
        A short text document explaining what license or licenses the
        content of the distribution is available under.  The filename
        `UNLICENSE` is used instead if (and only if) the entire contents of
        the distribution are in the [[Public Domain|public domain]].
    
    -   `make.sh` or `Makefile`
        
        A Bourne shell script which builds executables and related things
        from the sources included in the distribution.  This may also be
        a `Makefile`, but `Makefile`s are usually put in the `src`
        directory.  `make.sh` may just `cd` to that directory and run `make`.
        
    -   `test.sh`
        
        A Bourne shell script which runs tests for the distribution.  The
        tests can test anything they like, but should produce output which
        conforms to Portent format, which we haven't exactly defined yet, so
        don't worry about it.  For now, an exit code of 0 means pass,
        anything else means failure.
    
    Certain files in the root distribution directory have standard meanings as
    well:
    
    -   `bin`
        
        Where executables shoud be kept.  Distributions should generally not
        contain native executables; the main exception to this rule is native
        executables for "legacy platforms" such as [[MS-DOS]] and
        [[Commodore 64]] computers.
        
        Native executables may be written into the `bin` directory when they
        are built from other files in the distribution by e.g. `make.sh`.
        
        Distributions may contain non-native binary files intended to be
        executed, i.e. virtual machine code, and these will reside in `bin`.
        Java `.class` files are contained, under `bin`, in a directory tree
        matching the package names.
        
        Distributions may contain executable scripts.  However, executable
        scripts which contain significant amounts of source code (i.e. ones
        that are not just little drivers or wrappers) should go in `script`
        rather than `bin`.  They may in some cases be copied into `bin` upon
        build.
        
        Names of files in `bin` should not have extensions unless convention
        demands it.  (That is, `tool` rather than `tool.py`, but `tool.com`
        is OK.)
        
    -   `dialect`
        
        For distributions of programming (and other) languages, this is
        where related languages (usually too minor in variation to warrant
        their own distributions) are defined and implemented.
        
    -   `disk`
        
        Where disk images should be kept.
    
    -   `doc`
        
        Where documentation should be kept.  Exceptions include
        `README.markdown` and `LICENSE`, which should be in the root
        directory.
        
        Images may be included in `doc` if they are part of the
        documentation (for example, diagrams) but if they are just
        screenshots, they should probably be elsewhere.
    
    -   `ebin`
        
        Distributions should not ship with pre-compile Erlang `.beam` files,
        but when they are built from the sources, they will go here.  Erlang
        `.app` files may be contained here as well, but these are generally
        not all that useful, and mostly for decoration.
        
    -   `eg`
        
        Where examples should be kept, particularly example programs
        in distributions which contain implementations of programming
        languages.
        
    -   `impl`
        
        For distributions containing more than one implementation, this is
        where source code for the non-reference implementations should be
        kept.  (The reference implementation's source should be in `src`.)
        
    -   `priv`
        
        Where data files for Erlang applications are kept.
        
    -   `script`
        
        Where executable scripts which have significant amount of code in
        them should be kept.  (But if the script gets really large, it should
        probably be broken up into a driver script in `bin` which imports
        source modules from `src`.)
        
    -   `src`
        
        Where source code is kept.  For distributions containing more than
        one implementation, this is where the reference implementation is
        kept; other implementations should probably be in `impl` instead.


Computer Science Education:
  type: Discipline
  commentary: |
    Well, here we are — 2008. We've been teaching computer science for,
    what, half a century so far? Wow. We must be getting pretty good at it
    by now. Let's look as the state of the art...
    
    Oh, interesting. In January, some professors wrote a
    [paper](http://www.stsc.hill.af.mil/CrossTalk/2008/01/0801DewarSchonberg.html "Computer Science Education: Where Are the Software Engineers of Tomorrow?")
    that claims that CS education lacks mathematical rigour and leaves
    students ill-equipped for genuine software development, and suggests
    that CS curricula emphasize formal methods.
    
    Egad! Is it really
    [1988](http://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html "On the cruelty of really teaching computing science")
    *again*? So *soon*?
